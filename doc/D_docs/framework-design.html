<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN"><HTML><HEAD>	<META NAME="GENERATOR" Content="Symantec Visual Page 1.0.2">	<META HTTP-EQUIV="Content-Type" CONTENT="text/html;CHARSET=iso-8859-1">	<TITLE>untitled</TITLE></HEAD><BODY BGCOLOR="#FFFFFF"><P><IMG SRC="bluesky.gif" WIDTH="46" HEIGHT="1200" ALIGN="LEFT" BORDER="0" HSPACE="4"><FONTSIZE="6"><B>Frameworks and D</B></FONT><BLOCKQUOTE>	<P><FONT SIZE="1">Russell</FONT></P>	<P>The <A HREF="dReference.html">D C++ classes</A> is a C++ component mini-framework	that provides meta-level information and behavior for unprecedented flexibility and	extensibility in C++ software.</P>	<H2>Why</H2>	<P><FONT SIZE="1">Nov 12, 1998</FONT></P>	<P>There is no growth without change. The inability to change is the inability to	grow. What is more difficult to change in software than assumptions? The most difficult	assumptions to change are those which span systems or components; the most fluid	designs allow for system wide assumptions, such as inter-component associations and	communication, to be dynamic. In software, <I>dynamic</I> implies <I>behavior</I>	rather than <I>structure</I>, particularly as applied to <I>data</I>. When all things	inter-component are dynamic, the components may grow independently, and since &quot;the	system&quot; is defined as the interaction of its components, the definition of the	system itself is dynamic. Ultimately, each component itself may be such a system,	and we have a dynamic system of dynamic systems of dynamic systems of dynamic systems...	what we're left with is a concept of dynamic structure. &quot;The system&quot; has	no static structure except in an instantaneous sense; the definition of the system	includes the fact that it is changing in time, just as acceration is a change in	velocity in time, and velocity is a change in position in time. This reflects, finally,	the reality that the only general case that matters is <I>things will change</I>.</P>	<P>What can we do to move to this vision? First let's figure out where we are. In	the real world we have C++ and Java as the most mainstream languages. The first questions	are how to identify assumptions and minimize their proliferation - with the realization	that we can't solve this general case from within C++ or Java. As wonderful as change	management design patterns are, you have to <I>knowingly</I> apply them, and the	irony is we do this in a particular area <I>because</I> we're expecting change! Reality	is different - it is rarely the case that a system will change in the ways we predict.	If we can apply change oriented design patterns <I>underneath</I> the language, then	we will be able to deal with change at every level. The challenge is how to do this	in mainstream languages like C++ and Java.</P>	<P>One significant kind of assumption is a dependency - one class <I>depends on</I>	another. If the other needs to change, the one must accomodate for this change. A	tight network of dependencies means massive ripple effects for even the smallest,	seemingly innocuous change. The full extent of such changes are very difficult to	track, and depends significantly on how well the system was designed. The unfortunate	reality is that a good design is like a good intention - it cannot predict or guarantee	the outcome. The best design created by nearly omniscient abstractionists can be	destroyed by one simple unexpected dependency when the system needs to be changed.	We need to implement a deeper infrastructure to deal with such things than expecting	good design to take care of something it cannot.</P>	<P>There is nothing we can do to prevent or make up for bad design; what we can do,	however, is make, as much as possible, such dependencies <I>dynamic</I>. Let us look	at this in more detail.</P>	<P>When, in C++ or Java, I decide that an object should be composed of several other	objects, some assumptions that get solidified are:</BLOCKQUOTE><OL>	<OL>		<LI>instances have several variables		<LI>subclasses also have these variables by inheritance		<LI>all subclass instances have these variables		<LI>variables are inaccessible to those who don't know the exact class or class heritage	</OL></OL><BLOCKQUOTE>	<P>On the surface these seem obvious assumptions. But what does it mean that an object	has a variable? Does it mean that, in C++, the object has a pointer? Perhaps it is	a &quot;smart&quot; pointer. Perhaps it is a super-smart pointer which looks up the	requested class <I>by name</I>.</P>	<P>	<H2>How</H2>	<P><FONT SIZE="1">Oct 28, 1998</FONT></P>	<P>The <A HREF="d-triangle-hierarchy.gif">D C++ classes</A> is a C++ component mini-framework	that provides meta-level information and behavior for unprecedented flexibility and	extensibility in C++ software. But it is fundamentally incomplete: it needs application	or environment-specific frameworks to integrate these objects into an environment,	such as:</P></BLOCKQUOTE><UL>	<UL>		<LI>a C++ program that simply uses a few D classes (no framework)		<LI>a COM component that glues COM's messaging system to the D abstract messaging		system		<LI>a set of application-specific KIVA components that use D objects		<LI>a generic Net Dynamics application server component that services Foundation		<LI>a Granite Foundation Resource and library component that provides class loading,		messaging, and data translation when necessary	</UL></UL><BLOCKQUOTE>	<P>These frameworks span from the non-existent to the very complex. Much of the differences	among them represent different perspectives on <I>dynamic messaging</I>, loadable	library structure, and OS-specific details.</P>	<P>The purpose of this C++ implementation of D is:</P></BLOCKQUOTE><OL>	<OL>		<LI>provide a C++ standard for Destiny Software		<LI>allow Destiny C++ objects to be independent of Granite Foundation		<LI>provide a way for objects to seamlessly integrate into a dynamic system such		as Foundation	</OL></OL><BLOCKQUOTE>	<P>The last goal is accomplished by providing meta-level data structures, virtual	data, dynamic messaging and memory management for those C++ objects which adhere	to this standard. This meta-level information allows much of the extreme flexibility	found in dynamic languages while maintaining the benefits of C++'s standardization	and speed.However, these objects are incomplete in the sense that they are not integrated	into any specific enviornment; an environment- or application-specific framework	must be created into which these components can be plugged. A &quot;framework&quot;	is a semi-complete application, and would provide the following for D objects:</P></BLOCKQUOTE><UL>	<UL>		<LI>class loading, as from shared or dynamic libraries		<LI>environment- or application-specific messaging (COM, CORBA, OFX, RSL/ECI, etc.)		<LI>environment- or application-specific logging, etc.	</UL></UL><BLOCKQUOTE>	<P>Such a framework is implemented for Granite Foundation today. In fact, Foundation	has been modified to take advantage of it in a very tight and efficient manner because	D objects, implemented in C++, maybe used from within Foundation's dyanmic language	RSL as if they were native RSL-defined objects - far more tightly integrated than	Foundation's own C++ standard.</P></BLOCKQUOTE><P><HR></BODY></HTML>