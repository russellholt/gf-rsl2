<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN"><HTML><HEAD>	<META NAME="GENERATOR" Content="Symantec Visual Page 1.0.2">	<META HTTP-EQUIV="Content-Type" CONTENT="text/html;CHARSET=iso-8859-1">	<TITLE>untitled</TITLE></HEAD><BODY BGCOLOR="#FFFFFF"><CENTER><P><A HREF="DestinyC++.html"><FONT SIZE="2">Destiny C++</FONT></A> | <A HREF="Overview.html"><FONTSIZE="2">Overview</FONT></A> | <A HREF="dReference.html"><FONT SIZE="2">Reference</FONT></A><FONT SIZE="2">| Sorting</FONT><BR><A HREF="Objects.html"><FONT SIZE="2">Class and Object Design</FONT></A> | <A HREF="rsl2d.html"><FONTSIZE="2">rsl2D</FONT></A> | <A HREF="R_D.html"><FONT SIZE="2">R_D</FONT></A> | <AHREF="Dfaq.html"><FONT SIZE="2">Martin's Questions</FONT></A> <HR></P></CENTER><H1>Sorting and Comparison</H1><P><FONT SIZE="4" COLOR="#DD0000"><I>In <B>Progress</B>! Highly <B>Unfinished</B>!But you can get the <B>basic ideas</B>..</I></FONT></P><UL>	<LI><B>Sorting</B>	<UL>		<LI><A HREF="#basic sorting">basic</A>		<LI><A HREF="#advanced sorting">advanced</A>		<LI>others	</UL>	<LI><A HREF="#comparison"><B>Comparison</B></A>	<UL>		<LI><A HREF="#Complex composite comparison">complex composites</A>	</UL></UL><P>In Summary,</P><P>There are many ways to sort Composite objects, such as:</P><P><TABLE BORDER="0" CELLPADDING="2" CELLSPACING="0" WIDTH="100%">	<TR>		<TD WIDTH="2%" VALIGN="TOP"><B><I>complexity</I></B></TD>		<TD VALIGN="TOP"><B><I>how</I></B></TD>		<TD VALIGN="TOP"><B><I>preference</I></B></TD>		<TD VALIGN="TOP"><B><I>flexibility</I></B></TD>	</TR>	<TR>		<TD WIDTH="2%" VALIGN="TOP" BGCOLOR="#BBBBBB">low</TD>		<TD VALIGN="TOP" BGCOLOR="#BBBBBB"><CODE>DO_List::sort()</CODE></TD>		<TD VALIGN="TOP" BGCOLOR="#BBBBBB">medium</TD>		<TD VALIGN="TOP" BGCOLOR="#BBBBBB">low</TD>	</TR>	<TR>		<TD WIDTH="2%" VALIGN="TOP">low</TD>		<TD VALIGN="TOP"><CODE>DO_List::sort(DR_comparator)</CODE> and specify the order of instance variables			with default the comparator class.</TD>		<TD VALIGN="TOP">high</TD>		<TD VALIGN="TOP">high</TD>	</TR>	<TR>		<TD WIDTH="2%" VALIGN="TOP" BGCOLOR="#BBBBBB">high</TD>		<TD VALIGN="TOP" BGCOLOR="#BBBBBB">override <CODE>DO_Composite::compare()</CODE></TD>		<TD VALIGN="TOP" BGCOLOR="#BBBBBB">low</TD>		<TD VALIGN="TOP" BGCOLOR="#BBBBBB">medium</TD>	</TR>	<TR>		<TD WIDTH="2%" VALIGN="TOP">highest</TD>		<TD VALIGN="TOP">subclass DR/DO_comparator, use SortedBinaryTree...</TD>		<TD VALIGN="TOP">medium</TD>		<TD VALIGN="TOP">highest</TD>	</TR></TABLE></P><H3><HR NOSHADE></H3><H3><A NAME="basic sorting"></A>basic sorting</H3><P><I>Sorting requires </I><A HREF="#comparison"><I>object comparison</I></A><I>,explained next.</I></P><P>The exact method names illustrated below may not yet be accurate: be sure andcheck the class definitions!<BR><TABLE BORDER="1" CELLPADDING="4" CELLSPACING="1" WIDTH="100%">	<TR>		<TD>			<PRE>	theList-&gt;sort();</PRE>		</TD>		<TD>Uses the default compare() methods, as defined by String, Int, Bool, Collection,			Composite, etc.</TD>	</TR>	<TR>		<TD VALIGN="TOP">			<PRE>	DR_comparator c;	c-&gt;<FONT COLOR="#330066">addName</FONT>(&quot;<FONT COLOR="#002200">fieldOne</FONT>&quot;);	c-&gt;<FONT COLOR="#330066">addName</FONT>(&quot;<FONT COLOR="#002200">fieldTwo</FONT>&quot;);	theList-&gt;<FONT COLOR="#330066">sort</FONT>(c);</PRE>		</TD>		<TD VALIGN="TOP">Allows precise specification of the order of comparison of instance variables in			composites. Here, corresponding variables named &quot;fieldOne&quot; are compared			first, followed by comparison of &quot;fieldTwo&quot;. It is not necessary to specify			the type of the objects in theList.</TD>	</TR>	<TR>		<TD>			<P>			<PRE>	DR_comparator c;	c &lt;&lt; &quot;<FONT COLOR="#002200">fieldOne</FONT>&quot; &lt;&lt; &quot;<FONT			COLOR="#002200">fieldTwo</FONT>&quot;;	theList-&gt;<FONT COLOR="#330066">sort</FONT>(c);</PRE>		</TD>		<TD>Same as the above, just more brevity.</TD>	</TR></TABLE></P><H3><A NAME="advanced sorting"></A>advanced sorting</H3><P>What if the instance variables of a composite are also composites -- and we wantto specify their order as well? Comparator has the ability to recognize that a fieldis a composite, and can store a dictionary of classname to comparator objects, sothat we can specify a &quot;sub&quot; comparator for each specific type of compositewe will need to compare in order to complete the sort. This is available via</P><BLOCKQUOTE>	<P><CODE>DO_comparator::addSubComparator ( const DR_String&amp; className, DR_comparator	c );</CODE></P></BLOCKQUOTE><P>If no comparator is specified for a particular composite class, the default <CODE>DO_Composite::compare()</CODE>will be used.</P><P>Sorting can be ... <TABLE BORDER="0" WIDTH="100%">	<TR>		<TD>			<PRE>	DR_SortedBinaryTree bt;	DR_comparator c;	c &lt;&lt; &quot;<FONT COLOR="#002200">fieldOne</FONT>&quot; &lt;&lt; &quot;<FONT			COLOR="#002200">fieldTwo</FONT>&quot;;	bt-&gt;comparator = c;	bt-&gt;<FONT COLOR="#330066">insertContents</FONT>(theList);	DR_List sorted = bt-&gt;root-&gt;<FONT COLOR="#330066">inOrder</FONT>();		</PRE>		</TD>		<TD>&#160;</TD>	</TR></TABLE><H3></H3><H4>Other ways to sort</H4><P>If neither overriding compare() nor specifying field order with comparators isquite right, try</P><UL>	<LI>implementing compare() using a comparator	<LI>subclass comparator	<LI>Use a combination...</UL><H3></H3><H3><A NAME="comparison"></A>Object comparison</H3><P>Sorting requires comparison, and there are two ways to compare D objects: usingthe basic default way, which always comes down to built-in comparison of atomic objectslike Strings; or a <A HREF="#Complex composite comparison">complex</A> way we canspecify the comparison order of composite instances dynamically - by using comparatorobjects.</P><P>The comparison function defined in the class D</P><BLOCKQUOTE>	<P><TT>virtual dcompare_t compare(const DRef&amp; d) const;</TT></P></BLOCKQUOTE><P>is implemented by the following DO_ classes:</P><UL>	<LI>Bool	<LI>Collection	<LI>Composite	<LI>Decimal	<LI>Dictionary	<LI>Int	<LI>String</UL><P>type <TT>dcompare_t</TT> is defined in D.h as:</P><BLOCKQUOTE>	<P><TT>enum dcompare_t { c_less=-1, c_equal=0, c_greater=1 };</TT></P></BLOCKQUOTE><P>This follows typical collation semantics.</P><H3><A NAME="Complex composite comparison"></A>Complex composite comparison</H3><P>Composite comparison needs to be more flexible, since we may want to compare onlyby one instance variable, or by instance variables in a specific order, and we mayin fact want to sort in many different ways and we may want to change the order atruntime. Furthermore, a composite may be composed of other composites and they maybe composed still of others, and we perhaps would like to specify the order of collationall the way down.</P><P>In order to do this, we define a comparator object which specifies the order inwhich instance variables of a composite should be compared.</P><P>For example, given a list (DR_list) <I>theList</I> which contains instances ofa class that has variables named <I>var1</I> and <I>var2</I>, we can<H3></H3><H3><HR></H3><CENTER><P><A HREF="DestinyC++.html"><FONT SIZE="2">Destiny C++</FONT></A><B> </B>| <A HREF="Overview.html"><FONTSIZE="2">Overview</FONT></A><B> </B>| <A HREF="dReference.html"><FONT SIZE="2">Reference</FONT></A><B></B><FONT SIZE="2">| Sorting</FONT><B><BR></B><A HREF="Objects.html"><FONT SIZE="2">Class and Object Design</FONT></A><B> </B>|<B></B><A HREF="rsl2d.html"><FONT SIZE="2">rsl2D</FONT></A><B> </B>|<B> </B><A HREF="R_D.html"><FONTSIZE="2">R_D</FONT></A> | <A HREF="Dfaq.html"><FONT SIZE="2">Martin's Questions</FONT></A><HR></CENTER></BODY></HTML>