<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN"><HTML><HEAD>	<META NAME="GENERATOR" Content="Symantec Visual Page 1.0.2">	<META HTTP-EQUIV="Content-Type" CONTENT="text/html;CHARSET=iso-8859-1">	<TITLE>D_Objects</TITLE></HEAD><BODY BGCOLOR="#FFFFFF"><CENTER><P><A HREF="DestinyC++.html"><FONT SIZE="2">Destiny C++</FONT></A><B> </B>| <A HREF="Overview.html#TOC-Standard"><FONTSIZE="2">Overview</FONT></A><B> | </B><A HREF="dReference.html"><FONT SIZE="2">Reference</FONT></A><B><BR></B><FONT SIZE="2">Class and Object Design</FONT><B> | </B><A HREF="comparison.html"><FONTSIZE="2">Sorting</FONT></A><B> </B>| <A HREF="R_D.html"><FONT SIZE="2">R_D</FONT></A>|<B> </B><A HREF="rsl2d.html"><FONT SIZE="2">rsl2D</FONT></A><B> </B>| <A HREF="Dfaq.html"><FONTSIZE="2">Martin's Questions</FONT></A> <HR></P></CENTER><BLOCKQUOTE>	<H2><A NAME="top"></A>Class and Object Design</H2>	<P><B><I>all updated Dec 15, 1998</I></B></P>	<OL Type="I">	<LI><A HREF="#A Composite Example: DOAcct"><FONT SIZE="4">Object Basics</FONT></A>	<OL Type="A">		<LI>Composites		<OL>			<LI>DO_Acct example			<LI>composition			<LI>R_D: working with RSL			<LI>DR_Acct		</OL>		<LI><A HREF="#Method Invocation">Method invocation</A>	</OL>	<LI><A HREF="#Collections"><FONT SIZE="4">Collections</FONT></A> - updated 24 Sept	<FONT SIZE="2">(new enumeration example)</FONT>	<OL Type="A">		<LI>overview		<LI><A HREF="#Insertion">insertion</A>		<LI>deletion		<LI><A HREF="#Iteration">enumeration</A>		<LI><A HREF="#Sorting">sorting</A>		<LI><A HREF="#Creating new collection">creating new collection classes</A>	</OL>	<LI><A HREF="#Streaming"><FONT SIZE="4">Streaming</FONT></A>	</OL>	<P>All instance variables and objects in a design should be represented by DO_Object	classes, classified either as DO_Atom, DO_Collection, or DO_Composite as is most	appropriate. However, they are used by their companion DRef classes, or by DRef itself.	This allows data to be efficiently manipulated both in C++ and in RSL without data	copying, and it allows very complex object relationships to be available both in	RSL and C++.	<H2>Basic DR_Object - DO_Object Relationship</H2>	<P>The <A HREF="html/c++/DRef.html">DRef</A> class contains a pointer to a <A HREF="html/c++/D.html">D</A>;	but usually, this is too high level. Primarily we are concerned with the two subclasses	DR_Object and DO_Object; as strongly-typed smart pointers, is the job of every DRef	(or DR_Object) subclass to safely manage this pointer. It must provide</P>	<UL>	<LI><CODE>operator-&gt;()</CODE>	<LI><CODE>safe_get()</CODE>	<LI><TT>safe_set()</TT>	<LI><TT>New()</TT>	<LI>and any operator methods, as necessary, since they can't conveniently be called	through <CODE>operator-&gt;()</CODE>.	</UL>	<P>The basic relationship between a DRef and a DO_Object is quite simple, and looks	like this:</P>	<CENTER>	<P><IMG SRC="art/dref-obj.gif" WIDTH="169" HEIGHT="32" ALIGN="BOTTOM" BORDER="0"></CENTER>	<H3><A NAME="A Composite Example: DOAcct"></A><B>A Composite Example: DO_Acct</B></H3>	<P>Composite objects (those composed of other objects) inherit from the class <A	HREF="html/c++/DComposite.html"><B>DO_Composite</B></A>, and are essentially as simple	as this example account class with two instance variables, Name and Num:</P>	<CENTER>	<P>	<TABLE BORDER="0" CELLSPACING="0">	<TR>		<TD ALIGN="CENTER">			<P ALIGN="CENTER"><B>the class</B>		</TD>		<TD ALIGN="CENTER">			<P ALIGN="CENTER"><B>an instance</B>		</TD>	</TR>	<TR>		<TD COLSPAN="2"><HR SIZE="1" NOSHADE>		</TD>	</TR>	<TR>		<TD>			<PRE>class DO_Acct : public DO_Composite{	<B>DR_String Name, Num;</B>		<FONT COLOR="#330066">init</FONT>() {		Name.<FONT COLOR="#330066">New</FONT>();		Num.<FONT COLOR="#330066">New</FONT>();	}	<FONT COLOR="#FF0000">// ...</FONT>};</PRE>		</TD>		<TD><IMG SRC="art/composite-1.gif" WIDTH="295" HEIGHT="136" ALIGN="BOTTOM" BORDER="0"></TD>	</TR>	</TABLE></P></CENTER>	<P>It is important to keep these kinds of pictures in mind when thinking about DRef	and DO_Object relationships. The semantics of object copying, equality, assignment	can be complex at times. For example, there is a clear difference between copying	a <A HREF="html/c++/DRef.html">DRef</A> and copying a DO_Object! These issues are	discussed in depth elsewhere.</P>	<P><I>Comments and observations</I>	<OL>	<LI>Why doesn't DO_Acct declare DO_String objects, instead of the DR_String as here?	Two reasons, primarily. DO_Object classes are <I>always</I> managed by DRef objects	so that they can be shared between C++ and RSL, so they can be effectively recycled,	and so they can efficiently be copied.	<LI>The <CODE>init()</CODE> method above is analogous to a C++ constructor. The D	system has memory management; DO_Objects are reclaimed and recycled when no longer	referenced any more. There are free lists of DO_Objects that are not in use, and	conseqently, they are not actually destroyed.	<LI>A DRef, like the DR_String declarations in the class DO_Acct above, are initially	&quot;null&quot;. Like the declaration of a C pointer, they point to nothing. Unlike	the declaration of a C pointer, they are initialized to the object <CODE>DNULL</CODE>;	the C++ expression <CODE>if (Name == DNULL)</CODE> will initially yield <CODE>true</CODE>.	<LI>To be most useful, the DO_Acct needs a DRef class -- DR_Acct. We'll implement	it in a moment. First, more details.	</OL>	<P><A NAME="Abstract Composition"></A><B>Abstract Composition</B><BR>	Now, one of the reasons for the existence of this system is so the objects may be	efficiently shared with RSL in Foundation. RSL needs to do things like ask an object	for an instance variable by name. RSL needs, also, to iterate over the instance variables	of such objects, regardless of their class, for efficient object streaming, equality,	assignment, etc. For this purpose, the superclass DO_Composite implements an instance	variable lookup table, so that the picture expands to be this:</P>	<CENTER>	<P>	<TABLE BORDER="0" CELLSPACING="0">	<TR>		<TD>			<P ALIGN="CENTER"><B>the class</B>		</TD>		<TD>			<P ALIGN="CENTER"><B>an instance</B>		</TD>	</TR>	<TR>		<TD COLSPAN="2"><HR SIZE="1" NOSHADE>		</TD>	</TR>	<TR>		<TD VALIGN="TOP">			<PRE>class DO_Acct : public DO_Composite{	DR_String Name, Num;		void <FONT COLOR="#330066">init</FONT>() {		<FONT SIZE="4" COLOR="#330066"><B>add</B></FONT><FONT SIZE="4">(</FONT>&quot;<FONT			COLOR="#006600">Name</FONT>&quot;, Name.<FONT COLOR="#330066">New</FONT>()<FONT SIZE="4">);</FONT>		<FONT SIZE="4" COLOR="#330066"><B>add</B></FONT><FONT SIZE="4">(</FONT>&quot;<FONT			COLOR="#006600">Num</FONT>&quot;, Num.<FONT COLOR="#330066">New</FONT>()<FONT SIZE="4">);</FONT>	}	<FONT COLOR="#FF0000">// ...</FONT>};</PRE>		</TD>		<TD VALIGN="TOP"><IMG SRC="art/composite-2.gif" WIDTH="295" HEIGHT="230" ALIGN="BOTTOM" BORDER="0"></TD>	</TR>	</TABLE></P></CENTER>	<P>By doing this, anyone can ask for the object &quot;Name&quot; and get DRef to	the DO_String. Anyone, including RSL. This is exactly how RSL and C++ will share	information efficiently.</P>	<UL>	<LI><FONT SIZE="2">It's not clear whether this collection is necessary in all cases,	since clearly it can be constructed as necessary.</FONT>	</UL>	<P><A NAME="Working with RSL: R_D"></A><B>Working with RSL: R_D</B><BR>	The Foundation 2.5 Resource <A HREF="R_D.html"><B>R_D</B></A> is introduced to solve	the problem in the Resource/RSL side of things. It contains a DRef, also, and it	is a mighty morphin' power Resource, which takes on the characteristics of the particular	DO_Object it points to. For example, in the picture below, the DO_Acct object is	available in RSL, and by asking it for &quot;Name&quot;, one can use this DO_String	in both C++ and RSL:</P>	<BLOCKQUOTE>		<P><IMG SRC="art/composite-3.gif" WIDTH="473" HEIGHT="324" ALIGN="BOTTOM" BORDER="0"></P>		<P><FONT SIZE="2">The coloring in this diagram of the R_D instances reflects the		fact that the &quot;character&quot; of an R_D instance changes according to the specific		kind of DO_Object they point to. R_D<SUB>1</SUB>, for example, takes on the appearance		of being an &quot;account&quot; from RSL's perspective.</FONT></P>	</BLOCKQUOTE>	<P><A NAME="DRAcct"></A><B>DR_Acct</B><BR>	Now, as we have seen, to be most useful DO_Objects need companion DRef objects. Let's	see what these actually look like by implementing the DR_Acct class, and we'll add	more details to the DO_Acct as well.</P>	<CENTER>	<P>	<TABLE BORDER="0" CELLSPACING="0">	<TR>		<TD>			<P ALIGN="CENTER"><B>class</B>		</TD>		<TD>			<P ALIGN="CENTER"><B>instance</B>		</TD>	</TR>	<TR>		<TD COLSPAN="2"><HR SIZE="1" NOSHADE>		</TD>	</TR>	<TR>		<TD VALIGN="TOP">			<PRE>class DR_Acct : public DR_Object{	<FONT COLOR="#330066"><B>DR_Acct</B></FONT>(<FONT COLOR="#330066">const</FONT> DRef&amp; ref);	DO_Object *<FONT COLOR="#330066"><B>operator-&gt;</B></FONT>();};						class DO_Acct : public DO_Composite{	DR_String Name, Num;		void <FONT COLOR="#330066">init</FONT>() {		<FONT COLOR="#330066">add</FONT>(&quot;<FONT COLOR="#006600">Name</FONT>&quot;, Name.<FONT			COLOR="#330066">New</FONT>());		<FONT COLOR="#330066">add</FONT>(&quot;<FONT COLOR="#006600">Num</FONT>&quot;, Num.<FONT			COLOR="#330066">New</FONT>());	}	void <FONT COLOR="#330066"><B>destroy</B></FONT>() {		Name.<FONT COLOR="#330066">dump</FONT>();		Num.<FONT COLOR="#330066">dump</FONT>();	}};</PRE>		</TD>		<TD VALIGN="TOP"><IMG SRC="art/composite-4.gif" WIDTH="295" HEIGHT="295" ALIGN="BOTTOM" BORDER="0"></TD>	</TR>	</TABLE></P></CENTER>	<P><I>Comments</I>	<OL>	<LI>The DR_Acct constructor is implemented as:	<PRE>	<FONT COLOR="#330066">DR_Acct::DR_Acct</FONT>(const DRef&amp; ref) : DR_Object(ref) { }</PRE>	<P>The superclass DR_Object manages setting the pointer - which is what DR_ subclasses	are, anyway: smart pointers which do safe type casting.</P>	<LI>The method <TT>operator-&gt;()</TT> allows DR_Acct to pass-through to DO_Acct	underneath it, safely. (see Method Invocation for details)	<P>	<LI>The <FONT COLOR="#330066"><CODE>destroy</CODE></FONT><CODE>()</CODE> method is	analogous to a C++ destructor. Note in the picture that there are two references	to each of the DO_Acct instance DO_Objects; only one of them, in the DO_Collection,	can be automatically freed. The other must be done, explicitly, in the <FONT COLOR="#330066"><CODE>destroy</CODE></FONT><CODE>()</CODE>	method.	</OL>	<H3><A NAME="Method Invocation"></A>Method Invocation</H3>	<P>This standard sees dramatic improvements in the use of C++ from within both C++	and RSL. The only way to do this smoothly is to allow the same behavior to be invoked	from both environments - with native function calling or message passing semantics	in each environment. Continuing the above example, if we add a method doit(DR_String,	DR_Int) to the DO_Account class, it might look like the code below. For the purposes	of example, the doit() method is not very complex or interesting, and not something	that an &quot;Account&quot; would necessarily want to do.</P>	<BLOCKQUOTE>		<PRE>class DR_Acct : public DRef{	<FONT COLOR="#444444">DR_Acct(const DRef&amp; ref);	DO_bject *operator-&gt;();</FONT>};						class DO_Acct : public DO_Composite{	<FONT COLOR="#444444">DR_String Name, Num;</FONT>		<FONT SIZE="4">DR_List </FONT><FONT SIZE="4" COLOR="#330066"><B>doit</B></FONT><FONT		SIZE="4">(DR_String s, DR_Int i) {		i++;		</FONT><FONT SIZE="4" COLOR="#FF0000">	// change the argument</FONT><FONT		SIZE="4">		DR_List l();	</FONT><FONT SIZE="4" COLOR="#FF0000">// declare reference object and instantiate</FONT><FONT		SIZE="4">		l-&gt;</FONT><FONT SIZE="4" COLOR="#330066">append</FONT><FONT SIZE="4">(i);	</FONT><FONT		SIZE="4" COLOR="#FF0000">// add to the list</FONT><FONT SIZE="4">		return l;		</FONT><FONT SIZE="4" COLOR="#FF0000">// send this new list out</FONT><FONT		SIZE="4">	}</FONT>		<FONT SIZE="4">DRef </FONT><FONT SIZE="4" COLOR="#330066"><B>route</B></FONT><FONT		SIZE="4">(DR_Message m) {		</FONT>switch(m.method_id) {			case _hdoit:<FONT SIZE="4">				</FONT><FONT SIZE="4" COLOR="#330066">return</FONT><FONT SIZE="4"> </FONT><FONT		SIZE="4" COLOR="#330066">doit</FONT><FONT SIZE="4">(					</FONT><FONT SIZE="4" COLOR="#330066">DR_String</FONT><FONT SIZE="4">(m[0]), </FONT><FONT		SIZE="4" COLOR="#FF0000">// cast from DRef to DR_String</FONT><FONT SIZE="4">					</FONT><FONT SIZE="4" COLOR="#330066">DR_Int</FONT><FONT SIZE="4">(m[1]) );  </FONT><FONT		SIZE="4" COLOR="#FF0000">// cast from DRef to DR_Int</FONT><FONT SIZE="4">					</FONT>default: return <FONT COLOR="#330066">DO_Composite::route</FONT>(m);<FONT		SIZE="4">		}	}</FONT>	<FONT COLOR="#444444">void init() {		add(&quot;Name&quot;, Name.New());		add(&quot;Num&quot;, Num.New());	}	void destroy() {		Name.dump();		Num.dump();	}</FONT>	};</PRE>	</BLOCKQUOTE>	<P>The method <B><TT>route</TT></B> is the transaction-oriented messaging interface	which is used by RSL. From within C++, most often the use will be through the <TT>operator-&gt;()</TT>	method of DR_Acct, such as</P>	<PRE>	DR_Acct acct;	acct-&gt;<FONT COLOR="#330066">getStatements</FONT>(...);	</PRE>	<P>By structuring the system this way, the C++ function getStatements(DR_DateRange	dates) is exposed to RSL, literally, in a way that is type-safe from the perspective	of C++, <B>without data copying or translation of any kind</B>.</P>	<P><A HREF="rsl2d.html"><B>rsl2D</B></A><BR>	In Foundaton 2.2 and prior, the tool <TT>rsl2c++</TT> was used to generate a C++	Resource from an RSL class. Its primary drawback was that it was not smart enough	to allow the C++ resources to use &quot;regular&quot; C++ function call semantics.</P>	<P><A HREF="rsl2d.html">rsl2D</A> is this system's analogue to rsl2c++. Actually,	rsl2D is a facade on top of a new more general tool that is the center of rsl2D,	<A HREF="rsl2d.html">autodoc</A>, and in the future, rsl2java, rsl2resource, ....	<H2><A NAME="Collections"></A>Collections</H2>	<P>A collection is a class whose sole purpose is to group objects. Lists, arrays,	hash tables, binary trees are all collections. These classes are all subclasses of	<A HREF="html/c++/DCollection.html">DO_Collection</A>.</P>	<P>All collections store DRef objects; the interface to collection objects speak	in terms of <A HREF="html/c++/DRef.html">DRef</A> objects. Insertion, deletion, iteration,	and sorting are described below and refer to the following example:</P>	<PRE>	<A HREF="html/c++/DList.html">DR_List</A> thelist = DR_List::<FONT COLOR="#330066">New</FONT>();	DR_String s1 = &quot;<FONT COLOR="#006600">a</FONT>&quot;;</PRE>	<P>Because there can be wide variation among collections classes, their interfaces	also vary widely. Adding an element to a list requires less information than a hash	table, but the elements of both classes can be <A HREF="#Iteration">enumerated</A>.</P>	<P><A NAME="Insertion"></A><B>Insertion</B></P>	<P>Generally done via the methods <FONT COLOR="#330066"><CODE>add</CODE></FONT><CODE>(const	DRef&amp;)</CODE>, although subclasses such as DO_Dictionary require a key for each	element and so provide additional insertion methods.</P>	<PRE>	thelist-&gt;<FONT COLOR="#330066">add</FONT>(s1);</PRE>	<P>Let's analyze this seemingly simple statement. First, note that it was mentioned	earlier that every collection contains DRef objects explicity, not sublcasses. Yet	here, we're asking it to insert a DR_String object, explicitly. What is going on?	The following diagram shows the details.</P>	<CENTER>	<P><IMG SRC="art/listwithstring.gif" WIDTH="248" HEIGHT="129" ALIGN="BOTTOM" BORDER="0"></P></CENTER>	<P>Both variables <I>s1</I> and <I>thelist</I> are <CODE>DRef</CODE> objects and	so point to their respective <CODE>DO_Object</CODE>s. This picture disregards the	internal implementation of DO_List - other than the fact that there is a DRef object.</P>	<P>If we were to add the same object again, that is if we repeated the statement	<TT>thelist-&gt;</TT><FONT COLOR="#330066"><TT>add</TT></FONT><TT>(s1); </TT>we would	have this:</P>	<CENTER>	<P><IMG SRC="art/listwith2strings.gif" WIDTH="248" HEIGHT="129" ALIGN="BOTTOM" BORDER="0"></P></CENTER>	<P>We could also add a string to the list this way:</P>	<PRE>	thelist-&gt;<FONT COLOR="#330066">add</FONT>( <FONT COLOR="#330066">DR_String</FONT>(&quot;<FONT	COLOR="#006600">a string</FONT>&quot;) );</PRE>	<P><A NAME="Deletion"></A><B>Deletion</B></P>	<BLOCKQUOTE>		<P>...	</BLOCKQUOTE>	<P><A NAME="Iteration"></A><B>Enumeration</B><BR>	<BR>	Each collection class has a companion enumerator class, subclass of <A HREF="html/c++/DEnumerator.html">DO_Enumerator</A>.	As much as possible, enumeration semantics are the same as in Java. Here is how we	do something to every string in a list:</P>	<PRE>	DR_String s;	<A HREF="html/c++/DEnumerator.html">DR_Enumerator</A> <FONT COLOR="#FF0000">en(thelist)</FONT>; <FONT	COLOR="#FF0000"><B>// this has a bug, use the below</B></FONT>	while (en-&gt;<FONT COLOR="#330066">hasMoreElements</FONT>())	{		s = en-&gt;<FONT COLOR="#330066">nextElement</FONT>();	}	DR_String s;	if (thelist.isValid())	{		<A HREF="html/c++/DEnumerator.html">DR_Enumerator</A> en = thelist-&gt;elements(); <FONT	COLOR="#FF0000"><B>// works</B></FONT>		while (en-&gt;<FONT COLOR="#330066">hasMoreElements</FONT>())		{			s = en-&gt;<FONT COLOR="#330066">nextElement</FONT>();		}	} // if	</PRE>	<P><HR>All this example does is change the DRef <TT>s</TT> to point to every DO_Object in	<TT>thelist</TT>. For a real example, consider the toString() method of DO_Collection,	which translates any subclass instance into a string:</P>	<PRE>	DR_String <A HREF="html/c++/DCollection.html#toString">DO_Collection::toString</A>()	{		DR_Enumerator dre(elements());		DR_String s;		while (dre-&gt;hasMoreElements())		{			s += dre-&gt;nextElement()-&gt;toString();		}		return s;	}</PRE>	<P>In the first example, the DR_Enumerator object is constructed with the collection	object; in the second, it is constructed with the result of the method elements().	These are the same; in the first, the call to elements() is implicit. This method	actually creates a DO_Enumerator object - the implementation side of the DR_Enumerator.	In fact, any specific DO_Enumerator will do -- and in this case, it is actually a	DO_ListEnumerator.</P>	<P><A NAME="Sorting"></A><B>Sorting and object comparison</B></P>	<P>Because <A HREF="html/c++/DComposite.html">DO_Composite</A> objects maintain a	collection of their instance variables, it is possible to write a completely <B><I>generic</I></B>	sort in which we can compare and order possibly heterogeneous objects on multiple	&quot;keys&quot;. This requires <A HREF="html/c++/Dcomparator.html">comparator</A>	objects, and the most direct interface is <A HREF="html/c++/DList.html#sort">DO_List::sort()</A>,	which uses <A HREF="html/c++/DSortedBinaryTree.html">SortedBinaryTree</A>. This has	been done and its details may be found in the <A HREF="comparison.html">Sorting and	Comparison</A> section.</P>	<P><A NAME="Creating new collection"></A><B>Creating new collection classes</B></P>	<P>In general, collections are actually implemented by <A HREF="http://vision.destinyusa.com/TechnicalOrg/3rdPartyTools/RogueWave/toolscr/appendix/appendix.htm">Rogue	Wave</A> collection classes. The one essential unifying detail is that they store,	by value, DRef objects. No collections by C++ pointer! It is the DRef classes which	maintain pointers. So, for example, the <A HREF="html/c++/DList.html">DO_List</A>	class uses the Rogue Wave collection class <A HREF="http://vision.destinyusa.com/TechnicalOrg/3rdPartyTools/RogueWave/toolscr/appendix/TVa_4775.htm"><TT>RWTValSlist&lt;DRef&gt;</TT></A>.	Now, because C++ requires objects to be a certain exact size in memory, we cannot	have a collection of hetereogeneous types <I>by value</I>; DRef serves this purpose	by being able to point to any DO_Object, and safe (dynamic) casting to specific classes	allows one to use a heterogeneous (by DO_Object) collection to store objects of a	specific type and still ensure C++-style type saftey.</P>	<P>Implementation-wise, the second example given above in <A HREF="#Insertion">Insertion</A>	looks like this:</P>	<CENTER>	<P><IMG SRC="art/listwithstringdetails.gif" WIDTH="307" HEIGHT="146" ALIGN="BOTTOM"	BORDER="0"></P></CENTER>	<H2></H2>	<H2><A NAME="Streaming"></A>Streaming</H2>	<P>There are two ways objects may be streamed: via the toString() method and using	an instance of classes derived from OStream. These produce String objects rather	than being streams in the sense of the C++ iostream class for the most flexibility.	The OStream hierarchy is, at the moment:</P>	<P>	<TABLE BORDER="0" WIDTH="80%">	<TR>		<TD>			<UL>				<LI><A HREF="html/c++/DOStream.html">OStream</A>				<UL>					<LI><A HREF="html/c++/DECI_OStream.html">ECI_OStream</A>					<LI>XML_OStream				</UL>			</UL>		</TD>		<TD VALIGN="TOP">			<P ALIGN="RIGHT"><FONT SIZE="2"><I>As usual, this hierarchy is deceptively simple.			In reality, there are </I>eight<I> C++ classes here...</I></FONT>		</TD>	</TR>	</TABLE></P>	<P>What is the difference? toString() is simple and not extensible; OStream is very	flexible. One example is that toString() of String just returns itself, whereas ECI	requires that strings be quoted and control characters translated (eg newline, etc).	ECI_OStream will do this.</P>	<H4>Examples</H4>	<P>	<TABLE BORDER="1" CELLPADDING="5" WIDTH="80%">	<TR>		<TD BGCOLOR="#BBBBBB">			<PRE>	<A HREF="html/c++/DList.html">DR_List</A> l;	// ... populate l ...	cout &lt;&lt; l-&gt;<B>toString</B>() &lt;&lt; endl;</PRE>		</TD>	</TR>	<TR>		<TD>			<PRE>	DR_List l;	// ... populate l ...	<A HREF="html/c++/DECI_OStream.html"><B>DR_ECI_OStream</B></A> eciout;	cout &lt;&lt; eciout-&gt;stream(l) &lt;&lt; endl;</PRE>		</TD>	</TR>	</TABLE></P>	<H4>How does it work?</H4>	<P>There are two basic kinds of objects: atoms and collections. Collections are divided	into those whose elements have a key and those that aren't. Collections, including	Composite, are collections of either other collections or atoms, so the question	comes down to dealing with each individual kind of atom, and then how these atoms	come together to form a stream. Because collections are abstract containers which	can be enumerated, a general streaming mechanism can be implemented provided that	the atoms can be streamed intelligently. In the case of the ECI_OStream, the special	cases are keyed collections (and thus composite), for which a key is required to	be associated with each element, and String which is quoted; other atoms are simply	toString()'d.</BLOCKQUOTE><CENTER><P><HR WIDTH="80%"><BR><A HREF="DestinyC++.html"><FONT SIZE="2">Destiny C++</FONT></A><B> </B>| <A HREF="Overview.html"><FONTSIZE="2">Overview</FONT></A><B><BR></B><A HREF="#top"><FONT SIZE="2">Class and Object Design</FONT></A><B> </B>| <AHREF="R_D.html"><FONT SIZE="2">R_D</FONT></A> |<B> </B><A HREF="rsl2d.html"><FONTSIZE="2">rsl2D</FONT></A><B> </B>|<B> </B><A HREF="Dfaq.html"><FONT SIZE="2">Martin'sQuestions</FONT></A><A HREF="theSystem.html"><FONT SIZE="2"><BR></A></FONT><HR WIDTH="80%"></CENTER></BODY></HTML>