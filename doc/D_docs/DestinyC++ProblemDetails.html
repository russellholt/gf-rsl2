<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN"><!--last modified on Fri, Sep 4, 1998 11:36 AM--><HTML><HEAD>	<META NAME="Author" Content="russell.holt@destinysoftware.com">	<META HTTP-EQUIV="Content-Type" CONTENT="text/html;CHARSET=iso-8859-1">	<TITLE>untitled</TITLE></HEAD><BODY TEXT="#FFFFFF" BGCOLOR="#440000" LINK="#FF6666" VLINK="#FF3300" ALINK="#FFFF33"><H2>A detailed look at the C++ and RSL (Foundation 2.2) Integration Issues</H2><BLOCKQUOTE>	<P><I>part of the </I><A HREF="DestinyC++.html"><I>Destiny C++ Standard</I></A></P>	<P>The current scheme for writing C++ in Granite Foundation is to write a Resource	class. This strategy works well for atomic objects, but has been judged too complex	for even relatively basic composite classes, and unusably complex for a design with	lots of interrelationships among the classes. In addition, many built-in facilities	of RSL are available for free to &quot;pure&quot; RSL classes, such as object streaming	and tests for equality, are simply not accessible to C++ generically; it requires	significant one-off C++ coding for each class that is <I>more complex</I> than the	general case. Ironically, Foundation 2.2 C++ Resources which are basically data-oriented	are 90% glue code; not only would a pure RSL version of them be significantly smaller,	but more efficient and more flexible. In summary, things that a C++ resource must	do for which the general case is already provided to pure RSL classes:</P>	<P><B>Accessor methods</B><BR>	Every instance variable for a C++ class must have Get and Set methods. Not only does	this add significant custom code to the objects, these methods must do data translation	between C++ classes and RSL. For example, if the account number is stored as a char	*, or any other non-Resource class, an equivalent Resource must be created and returned.	This means that if this accessor method is called repeatedly, a new Resource will	be created every time. This has another side effect, the next point, data duplication.</P>	<P><B>Data duplication</B><BR>	When the accessor method returns a new Resource, now there are two copies of this	datum.. If one is changed, now there are two different copies. Like two different	watches, like design and implementation, they probably will drift and can't easily	be synchronized.</P>	<BLOCKQUOTE>		<P><FONT SIZE="2"><B>A solution?</B><BR>		One obvious first step is to try and store C++ data objects as Resources. This would		eliminate the data copying problem of accessor methods except the need to write them,		and the data would not be duplicated. Unfortunately, Resources in Foundation 2.2		were not originally intended to be used from within C++ like this, and clearly this		places even more limitations on the use of such C++ classes outside of Foundation.		It is the desire to be able to write C++ that can be used both inside and outside		of Foundation which is driving some of the key design points of Destiny's C++ standard.</FONT></P>	</BLOCKQUOTE>	<P><B>Object streaming &amp; ECI</B><BR>	Granite Foundation is a foundation for our other products, notably Sculptor and its	descendants. ECI - the external client interface - is the mechanism by which these	communicate. It requires an object to be able to stream and destream in ECI format.	ECI's advantage is its extraordinary dynamic abilities; one can use it to externally	control Foundation including parsing and loading of libraries, new class declarations,	session instantionation, and arbitrary message passing. RSL classes get this functionality	for free - regardless of their complexity. C++ Resources do not, for the same reasons	that the rest of their downsides are: object structure is opaque from a dynamic perspective	and compiler-implementation dependent as well. In other words, each C++ Resource	must implement explicit streaming and destreaming; and again, the ironic reality	is that <I>this implementation is more complex for one individual C++ class than	it is for the general case in RSL</I>.</P>	<P><B>Object equality</B><BR>	RSL objects get a default member-by-member equality operation for free; not bit comparison,	but literally a message to each instance variable. If this is desired for the C++	class, equality operator has to be implemented.</P>	<P><B>Object Assignment</B><BR>	RSL objects get member-by-member assignment for free...</P>	<P><FONT SIZE="5"><B>the frontier</B></FONT><BR>	From one point of view, the above drawbacks are common to all distributed object	systems to one degree or another. There is no free lunch, so to speak, and the advantages	of meta-level facilities that one needs to do dynamic distributed objects certainly	require lots of &quot;glue&quot; code - at least, when using traditional compiled	languages.</P>	<P>RSL 2.1 and above have slowly introduced much more powerful facilities that simply	<I>require</I> object metadata and more advanced built-in functionality to work.	For example, in RSL 2.2, one may iterate across the instance variables of a object	of any type! <I>foreach instance variable</I>... Facilities like that are the beginning,	the essence of the abstract design layer. Compiled C++ is being left behind in this	realm because, as even the simple examples above illustrate, this is a hard problem.</P>	<P><B>A conclusion</B><BR>	There is a way, however, that it can be addressed for C++. There is a way that the	advantages of the abstract design layer and RSL can be given to C++ to some degree.	It will never be as fluid as RSL is, but that isn't bad - we don't want that to be	the case; that is what dynamic languages are for.</P>	<P>What we need, however, is an efficient way for arbitrarily complex C++ to work	as seamlessly as possible with RSL - so that the advantages of both systems are as	complementary as possible.</P></BLOCKQUOTE><P><A HREF="DestinyC++.html">forward to the Destiny C++ standard</A></BODY></HTML>