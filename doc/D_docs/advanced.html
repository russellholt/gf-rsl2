<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN"><HTML><HEAD>	<META NAME="GENERATOR" Content="Symantec Visual Page 1.0.2">	<META HTTP-EQUIV="Content-Type" CONTENT="text/html;CHARSET=iso-8859-1">	<TITLE>untitled</TITLE></HEAD><BODY BGCOLOR="#FFFFFF"><CENTER><P><A HREF="DestinyC++.html"><FONT SIZE="2">Destiny C++</FONT></A><B> </B>| <A HREF="Overview.html#TOC-Standard"><FONTSIZE="2">Overview</FONT></A><B> | </B><A HREF="dReference.html"><FONT SIZE="2">Reference</FONT></A><B><BR></B><A HREF="Objects.html"><FONT SIZE="2">Class and Object Design</FONT></A><B> </B>|<B></B><A HREF="rsl2d.html"><FONT SIZE="2">rsl2D</FONT></A><B> </B>| <A HREF="R_D.html"><FONTSIZE="2">R_D</FONT></A> | <A HREF="Dfaq.html"><FONT SIZE="2">Martin's Questions</FONT></A><BR><HR></P></CENTER><H1>Advanced topics</H1><OL Type="A">	<LI>Memory management	<OL>		<LI><A HREF="#Reference counting">Reference counting</A>, primary and secondary references		<LI><A HREF="#Recycling">Recycling</A>		<OL Type="a">			<LI>class objects		</OL>		<LI><A HREF="#Instantiation">Object instantiation</A>	</OL></OL><P><A NAME="Memory Management"></A><H2>Memory Management</H2><P><I>In this document, the word </I>object<I> generally refers to an instance inC++ of the class DR_Object or, of course, any of its subclasses. </I>DRef object<I>means an instance of DRef or any of its subclasses. This is the most basic divisionof object classification in the D class hierarchy. Also, with the exception of theclasses D and DRef, unless prefixed by either DO_ or DR_ a class name such as </I>List<I>should be interpreted to mean the concept of List as implemented by all of the classesassociated with it -- DR_List, DO_List, DOC_List, etc. and not any one specific class.</I></P><H3><A NAME="Reference counting"></A>Reference counting</H3><P>Objects are managed with a reference counting scheme that takes place in the constructorand destructor of DRef objects, and objects which are no longer needed are recycledby being pooled in class-specific collections for later use. The reference cycleproblem that a basic reference counting scheme has is circumvented by having twokinds of references: <B>primary</B> and <B>secondary</B>. Secondary references arenot counted for recycling purposes. An automated system could be built which doescycle detection to insert secondary references to break cycles, but at the moment,it is up to the programmer to determine when to make a secondary reference insteadof the default primary reference. Secondary references are used primary for &quot;backpointers&quot;. DRef objects keep separate numbers for primary and secondary references.</P><P>For example, to add an object to a List, which by default means inserting a DRefobject marked as being a primary reference,</P><BLOCKQUOTE>	<P><TT>DR_List l;<BR>	l-&gt;</TT><FONT COLOR="#330066"><TT>add</TT></FONT><TT>(anObject);</TT></P></BLOCKQUOTE><P>However, to make a secondary reference, we would</P><BLOCKQUOTE>	<P><TT>l-&gt;</TT><FONT COLOR="#330066"><TT>add</TT></FONT><TT>(anObject, <B>secondary_ref</B>);</TT></P></BLOCKQUOTE><P><I>secondary_ref</I> is an instance of the C++ enumerated type <TT>ref_t</TT>,defined in D.h as</P><BLOCKQUOTE>	<P><TT>enum ref_t { secondary_ref=0, primary_ref=1 };</TT></BLOCKQUOTE><P>Every collection method to add objects supports an optional final argument ofthis type whose default value is <TT>primary_ref</TT>.</P><P>From within RSL, a secondary reference may be added to a composite object viathe addPrivate() method of Composite.</P><H4><FONT SIZE="4">Danger!</FONT></H4><P><FONT COLOR="#770000"><B>Secondary references must be used with care</B></FONT>.Because they do not participate in reference counting that affects object lifetime,it is very possible that an object will be recycled which has secondary referencesto it. This is fine and expected as in the &quot;back pointer&quot; case, becauseit is expected that this condition is very temporary and the secondary referencewill be destroyed soon. The worst case is if the lifetime of the secondary referenceis much longer than all primary references to an object, in which case <B>the objectmay be recirculated in a new context</B>.</P><P>When it is known that the object to which a secondary reference will be removed,it is wise to dump() the secondary reference to avoid the possibility of accessingor prolonging this invalid reference.</P><H3><A NAME="Recycling"></A>Recycling</H3><P>All objects are managed by a DRef instance, somewhere, somehow. DRef is a hierarchyof strongly typed smart pointers which act as a pass through to the object and managethe object's reference count.</P><H4>Class Objects</H4><P>Every concept, such as List, has a static class object. In the case of List, itmeans that in addition to DR_List and DO_List, there is DOC_List which is derivedfrom DO_Class.</P><P><H2><A NAME="Instantiation"></A>Object Instantiation</H2><P><HR></P><CENTER><P><A HREF="#top">top</A></P><P><A HREF="DestinyC++.html"><FONT SIZE="2">Destiny C++</FONT></A><B> </B>| <A HREF="Overview.html#TOC-Standard"><FONTSIZE="2">Overview</FONT></A><B> | </B><A HREF="dReference.html"><FONT SIZE="2">Reference</FONT></A><B><BR></B><A HREF="Objects.html"><FONT SIZE="2">Class and Object Design</FONT></A><B> </B>|<B></B><A HREF="rsl2d.html"><FONT SIZE="2">rsl2D</FONT></A><B> </B>|<B> </B><A HREF="R_D.html"><FONTSIZE="2">R_D</FONT></A> | <A HREF="Dfaq.html"><FONT SIZE="2">Martin's Questions</FONT></A></CENTER></BODY></HTML>