<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN"><HTML><HEAD>	<META NAME="GENERATOR" Content="Symantec Visual Page 1.0.2">	<META HTTP-EQUIV="Content-Type" CONTENT="text/html;CHARSET=iso-8859-1">	<TITLE>untitled</TITLE></HEAD><BODY BGCOLOR="#FFFFFF"><CENTER><P><A NAME="Top"></A><A HREF="DestinyC++.html" target="_top"><FONT SIZE="2">DestinyC++</FONT></A><FONT SIZE="2"> | </FONT><A HREF="Overview.html" target="_top"><FONTSIZE="2">Overview</FONT></A><FONT SIZE="2"> | </FONT><A HREF="dReference.html"><FONTSIZE="2">Reference</FONT></A><FONT SIZE="2"><BR></FONT><A HREF="Objects.html" target="_top"><FONT SIZE="2">Class and Object Design</FONT></A><FONTSIZE="2"> | R_D | </FONT><A HREF="rsl2d.html"><FONT SIZE="2">rsl2D</FONT></A><FONTSIZE="2"> | </FONT><A HREF="comparison.html" target="_top"><FONT SIZE="2">Sorting</FONT></A><HR></P></CENTER><H1>R_D</H1><UL>	<LI><A HREF="#Method Mapping">Method Mapping</A>	<UL>		<LI><A HREF="#execute">execute</A>		<LI><A HREF="#RtoD">RtoD()</A>: map Resources to D objects		<LI><A HREF="#DtoR">DtoR()</A>: map D objects to Resources	</UL>	<LI><A HREF="#Class Mapping">Class Mapping</A></UL><P><B>R_D</B> is a Foundation 2.5 Resource whose job it is to represent <A HREF="html/c++/D.html">D</A>objects in Foundation. The D system knows nothing whatsoever of Granite Foundation,Resources, or RSL, but shares similar design goals although from a pure C++ perspective.Instances of R_D bridge the remaining gap. There is no similar D object.</P><P><B>Object mapping: RtoD() and DtoR()</B><BR>R_D contains a <A HREF="html/c++/DRef.html">DRef</A> instance variable (referredto hereafter as <B>dref</B>) and implements the standard Resource methods to constructDMessage objects (a DR_Message pointing to a DO_Message object, that is) which issent via <CODE>route()</CODE> to dref. In many cases, R_D has to map or convert betweenFoundation Resources and D objects; it does this via the methods <A HREF="#RtoD">RtoD</A>()and <A HREF="#DtoR">DtoR</A>(), documented below. It kind of looks like the diagrambelow, dotted arrows indicating function calls, and the solid arrow is a pointer:</P><CENTER><P><IMG SRC="art/R_Dmethods.gif" WIDTH="386" HEIGHT="218" ALIGN="BOTTOM" BORDER="0"></P></CENTER><P><B>Interface mapping: native RSL classes and <CODE>res_class</CODE></B><BR>Beyond method mapping, the real complexity is how does RSL know in the first placethat an R_D points to a specific kind of D. R_D's job is to take on the characteristicsof the specific kind of D that it points to, and the way that RSL determines theinterface supported by an object is by its class, defined by its RSL class declaration.This means that D objects, if they are to be useable from within RSL by any meanssuch as R_D, they must also describe their interface to RSL by declaring an RSL class,much like CORBA and COM objects do with their respective versions of IDL. See the<A HREF="#Class Mapping">Class Mapping</A> section below for more details.</P><H2><A NAME="Method Mapping"></A>Method Mapping</H2><P>Below is the approximate mapping between Resource methods and D methods. <B>dref</B>(all lowercase) is R_D's DRef instance variable.</P><CENTER><P><TABLE BORDER="1">	<TR>		<TD><B>Standard Resource method</B></TD>		<TD><B>what R_D implements</B></TD>	</TR>	<TR>		<TD><A HREF="#execute"><CODE>execute</CODE></A><CODE>()</CODE></TD>		<TD><CODE>route() <I>see </I></CODE><A HREF="#execute"><CODE><I>below</I></CODE></A></TD>	</TR>	<TR>		<TD><CODE>LogicalValue()</CODE></TD>		<TD><CODE>dref.isValid()</CODE></TD>	</TR>	<TR>		<TD><CODE>StrValue()</CODE></TD>		<TD><CODE>dref.toString()</CODE></TD>	</TR>	<TR>		<TD><CODE>Assign()</CODE></TD>		<TD><CODE>dref.assign()</CODE></TD>	</TR>	<TR>		<TD><CODE>Clear()</CODE></TD>		<TD><CODE>dref.dump()</CODE></TD>	</TR>	<TR>		<TD><CODE>IsEqual(Resource *R)</CODE></TD>		<TD><CODE>dref.compare(</CODE><A HREF="#RtoD"><CODE>RtoD</CODE></A><CODE>(R)) == c_equal</CODE></TD>	</TR>	<TR>		<TD><CODE>print(ostream&amp; out)</CODE></TD>		<TD><CODE>out &lt;&lt; dref.toString()</CODE></TD>	</TR></TABLE></P></CENTER><H2><A NAME="execute"></A>execute()</H2><P>this is the Resource method that is invoked when Resource methods are called fromRSL. R_D understands messages; for those it doesn't understand, it passes them onto its DRef by constructing a DMessage and invoking <CODE>dref.route()</CODE>.</P><P>R_D::execute() answers the following messages (as declared in RSL):</P><BLOCKQUOTE>	<P><CODE>String</CODE> <B>/</B> <CODE>( ) ;</CODE>	<BLOCKQUOTE>		<P>RSL member access operator. invokes dref.route() with a DMessage object with &quot;/&quot;		as the message name, and the argument named &quot;objectName&quot;. This essentially		maps between what is declared in Object.rsl and D.rsl.	</BLOCKQUOTE>	<P><CODE>Boolean</CODE> <B>isEqual</B> <CODE>( ) ;</CODE>	<BLOCKQUOTE>		<P>invokes R_D::IsEqual()	</BLOCKQUOTE>	<P><CODE>Boolean</CODE> <B>==</B> <CODE>( ) ;</CODE>	<BLOCKQUOTE>		<P>invokes R_D::IsEqual()	</BLOCKQUOTE>	<P><CODE>Object </CODE><B>assign</B> <CODE>( ) ;</CODE>	<BLOCKQUOTE>		<P>invokes R_D::Assign()	</BLOCKQUOTE>	<P><CODE>Object </CODE><B>:=</B> <CODE>( ) ;</CODE>	<BLOCKQUOTE>		<P>invokes R_D::Assign()	</BLOCKQUOTE>	<P><CODE>List </CODE><B>localVarNames</B> <CODE>( ) ;</CODE>	<BLOCKQUOTE>		<P>not a pass through: returns the memberOf()-&gt;localVarNames() (which is <CODE>res_class::localVarNames()</CODE>)	</BLOCKQUOTE></BLOCKQUOTE><P><H2><A NAME="RtoD"></A>RtoD</H2><P><CODE>R_D::RtoD(ResReference ref)</CODE> maps or converts Resources to D objects.Resource types are determined by the call to <CODE>Resource::TypeID()</CODE>, implementedby all Resources. The following Resource types are converted:</P><BLOCKQUOTE>	<P><B><CODE>R_D</CODE></B>	<BLOCKQUOTE>		<P>This is the most desirable case: here, the Resource is actually an R_D so we can		just return the D object it points to.	</BLOCKQUOTE>	<P><B><CODE>R_List</CODE></B>	<BLOCKQUOTE>		<P>This is the worst case; create a new <A HREF="html/c++/DList.html">DList</A> (DO_List)		and insert RtoD() for each element in the R_List.	</BLOCKQUOTE>	<P><B><CODE>R_Integer</CODE></B>	<BLOCKQUOTE>		<P>A new <A HREF="html/c++/DInt.html">DO_Int</A> is returned that has the value of		the R_Integer. See comments for R_String below.	</BLOCKQUOTE>	<P><B><CODE>R_Boolean</CODE></B>	<BLOCKQUOTE>		<P>A new <A HREF="html/c++/DBool.html">DO_Bool</A> is returned that has the value		of the R_Boolean. See comments for R_String below.	</BLOCKQUOTE>	<P><B><CODE>R_String</CODE></B>	<BLOCKQUOTE>		<P>R_String is itself a DRef object, and is actually implemented by a <A HREF="html/c++/DString.html">DO_String</A>,		thefore, its internal DO_String is returned. This is the way that R_Integer and R_Boolean		should be implemented.	</BLOCKQUOTE>	<P><B>general RSL object</B>	<BLOCKQUOTE>		<P>For instances of a pure RSL-defined class, a <A HREF="html/c++/DComposite.html">DO_Composite</A>		object is returned with RtoD() being called for each instance variable. Essentially		this is the same as the R_List example, with the elements of the RSL object being		stored in the DO_Composite's keyed collection storage, named as they are in the RSL		object.	</BLOCKQUOTE>	<P><B>finally,</B>	<BLOCKQUOTE>		<P>for those which are not listed above, is to create a new DString with the value		of the Resource's StrValue() method.</P>	</BLOCKQUOTE></BLOCKQUOTE><P><H2><A NAME="DtoR"></A>DtoR</H2><P>DtoR() maps or converts D objects to Resources. This requires that the D objecthave an associated DClass object (DO_Class) returned by its Class() method. Thisis used to determine the type.</P><BLOCKQUOTE>	<P><A HREF="html/c++/DString.html"><B>DO_String</B></A>	<BLOCKQUOTE>		<P>A new R_String wrapper is returned. Recall that R_String is itself implemented		by DO_String, so this is not a data copy.	</BLOCKQUOTE>	<P><A HREF="html/c++/DList.html"><B>DO_List</B></A>	<BLOCKQUOTE>		<P>a new R_List is created, inserting the results of calls to DtoR() for each element		in the DList.	</BLOCKQUOTE>	<P><A HREF="html/c++/DInt.html"><B>DO_Int</B></A>	<BLOCKQUOTE>		<P>a new R_Integer is returned with the value of the DO_Int	</BLOCKQUOTE>	<P><A HREF="html/c++/DBool.html"><B>DO_Bool</B></A>	<BLOCKQUOTE>		<P>a new R_Boolean is returned with the value of the DO_Bool	</BLOCKQUOTE>	<P><B>general </B><A HREF="html/c++/D.html"><B>D</B></A><B> object</B>	<BLOCKQUOTE>		<P>All others (except null) get a new R_D object created, storing a DRef to the given		D object. This R_D also points to the respective res_class instance created at startup		time that describes the &quot;native&quot; RSL class declaration for the D object,		if it is found.	</BLOCKQUOTE>	<P><B>null</B>	<BLOCKQUOTE>		<P>If the DRef is actually null, that is, isValid() returns FALSE, an R_D is returned		that points to null <CODE>(D* 0)</CODE> and whose res_class is that of D. This means		that <CODE>R_D::LogicalValue()</CODE> will invoke <CODE>dref.isValid()</CODE> which		will return false to RSL.	</BLOCKQUOTE></BLOCKQUOTE><H2><A NAME="Class Mapping"></A>Class Mapping</H2><P>Foundation represents these interfaces with the C++ class res_class. Each rslclass declaration has a corresponding res_class object at runtime. Every D concept(not class) has a corresponding RSL class declared to be a &quot;native&quot; class,eg <CODE>native class Collection { ... }</CODE> is stored in the file <A HREF="html/rsl/Collection.html">Collection.rsl</A>and corresponds to the C++ D classes <A HREF="html/c++/DCollection.html">DR_Collection</A>,DO_Collection, etc. The way this correspondence is made is a bit too complex to bedocumented right at this moment because today is my last work day before gettingmarried, so you'll have to look at examples.</P><P><HR><A HREF="#Top">Top</A></P><CENTER><P><A HREF="DestinyC++.html" target="_top"><FONT SIZE="2">Destiny C++</FONT></A><FONTSIZE="2"> | </FONT><A HREF="Overview.html" target="_top"><FONT SIZE="2">Overview</FONT></A><FONTSIZE="2"> | </FONT><A HREF="dReference.html"><FONT SIZE="2">Reference</FONT></A><FONTSIZE="2"><BR></FONT><A HREF="Objects.html" target="_top"><FONT SIZE="2">Class and Object Design</FONT></A><FONTSIZE="2"> | R_D | </FONT><A HREF="rsl2d.html"><FONT SIZE="2">rsl2D</FONT></A><FONTSIZE="2"> | </FONT><A HREF="comparison.html" target="_top"><FONT SIZE="2">Sorting</FONT></A></CENTER></BODY></HTML>