<HTML><HEAD><TITLE>DEnumerator</TITLE></HEAD><BODY BGCOLOR="#FFFFFF"><a name="#Top"> </a><h1>DEnumerator</h1><blockquote>	<p>generic interface for the enumeration of a collection of objects.</p>	<p>Depending on the specific implementation, it may be the case that the 	enumerator object wraps a Rogue Wave iterator object and as a result, the 	Rogue Wave iterator semantics apply, in which hasMoreElements() implies	"Advances the iterator one position. Returns TRUE if the new position is valid,	FALSE otherwise", and nextElement implies	"Returns the value at the iterator's current position.	The results are undefined if the iterator is no longer valid.".</p><h4>Example</h4>	<i>Traverse a list</i><PRE><CODE>	DR_List thelist;	DR_Enumerator e ( thelist-&gt;elements() );	while(e-&gt;hasMoreElements()) {		... e-&gt;nextElement() ...	}</CODE></PRE></blockquote><b>DEnumerator</b> is<UL>	<LI><a href="#DO_">DO_Enumerator</a> - abstract base class for implementations	<LI><a href="#DR_">DR_Enumerator</a> - the "smart pointer" reference to DO_Enumerator</UL><HR><a name="DO_"> </a><h2>class DO_Enumerator</h2><blockquote>	<blockquote>		a public subclass of <a href="DObject.html">DO_Object</a> . . . <a href="D.html">D</a>	</blockquote><h4>Public member functions</h4><blockquote>			<CODE>virtual BOOLEAN</CODE> <b>hasMoreElements</b>		<CODE>(  )=0;</CODE>	<blockquote>		 answer DR_TRUE if there are more elements in the collection.	</blockquote>	<CODE>virtual DRef</CODE> <b>nextElement</b>		<CODE>(  )=0;</CODE>	<blockquote>		 Return the next element in the list.	</blockquote></blockquote></blockquote><HR><!-- The DR class. First row is class name etc. --><a name="DR_"> </a><h2>class DR_Enumerator</h2><blockquote>	<blockquote>		a public subclass of <a href="DObject.html">DR_Object</a> . . . <a href="DRef.html">DRef</a>	</blockquote><h4>Constructor</h4><blockquote>	<CODE></CODE> <b>DR_Enumerator</b>		<CODE>( DR_Collection collection );</CODE>	<blockquote>		 Create a DO_Enumerator by invoking <CODE>collection-&gt;elements()</CODE>.		 This constructor should not be used. Instead, use DR_Enumerator(D *)		 with the invocation of <CODE>elements()</CODE> directly, such as in this		 example:	</blockquote></blockquote><h4>Standard DRef public member functions</h4><pre>	<a href="stdD.html#DR_d_constructor">DR_Enumerator (D *d=0)</a>;	<a href="stdD.html#DR_dref_constructor">DR_Enumerator (const DRef& ref)</a>;	virtual ~<a href="stdD.html#DR_destructor">DR_Enumerator()</a>;</pre><table border="1" cellpadding="3" cellspacing="0"><tr><td><div align="right"><I>note: <B>not</B> virtual functions</I></div><pre>	DO_Enumerator *<a href="stdD.html#DR_safe_get"><font size="+1"><b>safe_get</b></font></a>();	DO_Enumerator *<a href="stdD.html#DR_safe_set"><font size="+1"><b>safe_set</b></font></a>(D* d);	DO_Enumerator *<a href="stdD.html#DR_New"><font size="+1"><b>New</b></font></a>();	inline DO_Enumerator *<a href="stdD.html#DR_memberaccess"><font size="+1"><b>operator-></b></font></a>() { return <a href="stdD.html#DR_safe_get">safe_get</a>(); }</pre></td></tr></table></blockquote><HR><a href="#top">Top</a></BODY></HTML>