<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN"><HTML><HEAD>	<META NAME="GENERATOR" Content="Symantec Visual Page 1.0.2">	<META HTTP-EQUIV="Content-Type" CONTENT="text/html;CHARSET=iso-8859-1">	<TITLE>Dcomparator</TITLE></HEAD><BODY BGCOLOR="#FFFFFF"><P><A NAME="#Top"></A><H1>Dcomparator</H1><BLOCKQUOTE>	<P>Comparator is used for <A HREF="DComposite.html">Composite</A> object comparison.	Because composites have an instance variable dictionary, we can generically compare	two composites by specifying the order in which their instance variables will be	compared.</P>	<P>To specify the variable names and order, use <A HREF="#addName"><CODE>addName</CODE></A><CODE>()</CODE>	or <A HREF="#DR_"><CODE>operator&lt;&lt;</CODE></A><CODE>()</CODE> for each variable	name in the desired order of comparison, or use <A HREF="#setNameList"><CODE>setNameList</CODE></A><CODE>()</CODE>	with a pre-specified order.</P>	<P>Usually, comparator is used in conjunction with sorting, with <CODE>List::sort()</CODE>	or <A HREF="DSortedBinaryTree.html">SortedBinaryTree</A>.</P>	<P>In the case when an instance variable is itself a composite, we can <A HREF="#addSubComparator">specify	&quot;sub comparators&quot;</A> by creating a comparator for each kind of composite	will be encountered during the comparison of instance variables.</P></BLOCKQUOTE><P><B>Dcomparator</B> is<UL>	<LI><A HREF="#DO_">DO_comparator</A> - the implementation	<LI><A HREF="#DR_">DR_comparator</A> - the &quot;smart pointer&quot; reference to	DO_comparator</UL><P><HR><A NAME="DO_"></A><H2>class DO_comparator</H2><BLOCKQUOTE>	<BLOCKQUOTE>		<P>a public subclass of <A HREF="DObject.html">DO_Object</A> . . . <A HREF="DObject.html">DO_Object</A>		. . . <A HREF="D.html">D</A>	</BLOCKQUOTE>	<H4>Private instance variables</H4>	<BLOCKQUOTE>		<P><CODE>DR_List</CODE> <B>fieldNames</B>		<BLOCKQUOTE>			<P>The ordered list of instance variable, or field, names to be used when comparing			composites.		</BLOCKQUOTE>		<P><CODE>DR_Dictionary</CODE> <B>subcomparators</B>		<BLOCKQUOTE>			<P>A classname to DO_comparator map. comparators are added with <A HREF="#addSubComparator">addSubComparator</A>().		</BLOCKQUOTE>	</BLOCKQUOTE>	<H4>Public instance variables</H4>	<BLOCKQUOTE>		<P><CODE>int</CODE> <B>followSecondaryRefs</B>		<BLOCKQUOTE>			<P>A composite's storage may contain <B>secondary references</B>. This variable indicates			whether these secondary references should be considered for comparison. Objects may			have &quot;back&quot; pointers, and in some cases it may not matter which particular			object is back pointed to, for example.		</BLOCKQUOTE>	</BLOCKQUOTE>	<H4>Public Member Functions</H4>	<BLOCKQUOTE>		<P><A NAME="addName"></A> <A HREF="DRef.html"><CODE>DR_void</CODE></A> <B>addName</B>		<CODE>( const DR_String&amp; name );</CODE>		<BLOCKQUOTE>			<P>Add the given DR_String variable name to the name list.		</BLOCKQUOTE>		<P><A HREF="DRef.html"><CODE>DR_void</CODE></A> <B>addName</B> <CODE>( const char		*name );</CODE>		<BLOCKQUOTE>			<P>Add the given const char * variable name to the name list.		</BLOCKQUOTE>		<P><A HREF="DRef.html"><CODE>DR_void</CODE></A> <A NAME="setNameList"></A><B>setNameList</B>		<CODE>( DR_List names );</CODE>		<BLOCKQUOTE>			<P>Replaces the internal name list with the given name list object. (does <I>not</I>			call addName for each name in the list).		</BLOCKQUOTE>		<P><A HREF="DRef.html"><CODE>DR_void</CODE></A> <B>clearNames</B> <CODE>( );</CODE>		<BLOCKQUOTE>			<P>Clear the internal name list.		</BLOCKQUOTE>		<P><A NAME="addSubComparator"></A> <A HREF="DRef.html"><CODE>DR_void</CODE></A> <B>addSubComparator</B>		<CODE>( const DR_String&amp; className, DR_comparator c );</CODE>		<BLOCKQUOTE>			<P>Add a subcomparator for the given class name.		</BLOCKQUOTE>		<P><A HREF="D.html"><CODE>dcompare_t</CODE></A> <B>compare</B> <CODE>( const </CODE><A		HREF="DComposite.html"><CODE>DR_Composite</CODE></A><CODE>&amp; l, const </CODE><A		HREF="DComposite.html"><CODE>DR_Composite</CODE></A><CODE>&amp; r );</CODE>		<BLOCKQUOTE>			<P>Compare two composite objects element-by-element as specified in the fieldNames			list. That is, look up the named element in both l and r. If both elements are atoms,			inovke <CODE>D::compare()</CODE>. If elements are both composites, and their class			name is in the subcomparators dictionary, use that subcomparator to compare the elements.		</BLOCKQUOTE>		<P><A HREF="DRef.html"><CODE>DRef</CODE></A> <B>findSubCFrom</B> <CODE>( </CODE><A		HREF="DRef.html"><CODE>DRef</CODE></A><CODE>&amp; ref );</CODE>		<BLOCKQUOTE>			<P>Returns the sub comparator mapped to by the name of the class of the argument			<I>ref</I> in the subcomparators dictionary -- or DR_null if there is none.		</BLOCKQUOTE>	</BLOCKQUOTE>	<H4>Standard DO public member functions</H4>	<PRE>	DO_comparator();	DO_comparator(<A HREF="DRef.html">DRef</A> r);	virtual ~DO_comparator();	static <A HREF="DClass.html">DR_Class</A> comparatorclass;		<FONT COLOR="#008000">the class object</FONT>	static DR_comparator <A HREF="stdD.html#DO_New"><FONT SIZE="4"><B>New</B></FONT></A>();	<A HREF="DClass.html">DR_Class</A> <A HREF="stdD.html#DO_Class"><FONT SIZE="4"><B>DClass</B></FONT></A>();	DRef <A HREF="stdD.html#DO_route"><FONT SIZE="4"><B>route</B></FONT></A>(DR_<A HREF="DDMessage.html">Message</A> m);	void <A HREF="stdD.html#DO_init"><FONT SIZE="4"><B>init</B></FONT></A>();	void <A HREF="stdD.html#DO_destroy"><FONT SIZE="4"><B>destroy</B></FONT></A>();</PRE></BLOCKQUOTE><P><HR><!-- The DR class. First row is class name etc. --> <A NAME="DR_"></A><H2>class DR_comparator</H2><BLOCKQUOTE>	<BLOCKQUOTE>		<P>a public subclass of <A HREF="DObject.html">DR_Object</A> . . . <A HREF="DRef.html">DRef</A>	</BLOCKQUOTE>	<H4>Public member functions</H4>	<BLOCKQUOTE>		<P><CODE>DR_</CODE><A HREF="Dvoid.html"><CODE>void</CODE></A> <B>operator&lt;&lt;</B>		<CODE>( const DR_String&amp; field );</CODE>		<BLOCKQUOTE>			<P>invokes <CODE>safe_get()-&gt;</CODE><A HREF="#addName"><CODE>addName</CODE></A><CODE>(field)</CODE>		</BLOCKQUOTE>		<P><CODE>DR_</CODE><A HREF="Dvoid.html"><CODE>void</CODE></A> <B>operator&lt;&lt;</B>		<CODE>( const char * field );</CODE>		<BLOCKQUOTE>			<P>invokes <CODE>safe_get()-&gt;</CODE><A HREF="#addName"><CODE>addName</CODE></A><CODE>(field)</CODE>		</BLOCKQUOTE>	</BLOCKQUOTE>	<H4>Standard DRef public member functions</H4>	<PRE>	<A HREF="stdD.html#DR_d_constructor">DR_comparator (D *d=0)</A>;	<A HREF="stdD.html#DR_dref_constructor">DR_comparator (const DRef&amp; ref)</A>;	virtual ~<A HREF="stdD.html#DR_destructor">DR_comparator()</A>;</PRE>	<P>	<TABLE BORDER="1" CELLPADDING="3" CELLSPACING="0">	<TR>		<TD>			<P ALIGN="RIGHT"><I>note: <B>not</B> virtual functions</I>			<PRE>	DO_comparator *<A HREF="stdD.html#DR_const_get"><FONT SIZE="4"><B>const_get</B></FONT></A>() <B>const</B>;	DO_comparator *<A HREF="stdD.html#DR_safe_get"><FONT SIZE="4"><B>safe_get</B></FONT></A>();	DO_comparator *<A HREF="stdD.html#DR_safe_set"><FONT SIZE="4"><B>safe_set</B></FONT></A>(D* d);	DO_comparator *<A HREF="stdD.html#DR_New"><FONT SIZE="4"><B>New</B></FONT></A>();	inline DO_comparator *<A HREF="stdD.html#DR_memberaccess"><FONT SIZE="4"><B>operator-&gt;</B></FONT></A>() { return <A			HREF="stdD.html#DR_safe_get">safe_get</A>(); }</PRE>		</TD>	</TR>	</TABLE></BLOCKQUOTE><P><HR><A HREF="#top">Top</A></BODY></HTML>