<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN"><HTML><HEAD>	<META NAME="GENERATOR" Content="Symantec Visual Page 1.0.2">	<META HTTP-EQUIV="Content-Type" CONTENT="text/html;CHARSET=iso-8859-1">	<TITLE>DClass</TITLE></HEAD><BODY BGCOLOR="#FFFFFF"><P><A NAME="#Top"></A><H1>DClass</H1><blockquote>Most D concepts are represented by three to four C++ classes: List, for example,consists of the C++ classes DR_List, DO_List, DO_ListEnumerator (private), and DOC_List.That is, a reference, an "object", an enumerator, and a class object. This class objectClass provides dynamic identification and instance recycling for D concepts.	In the future, Class will also store a representation of the concept's interface.</blockquote><P><B>DClass</B> is<UL>	<LI><A HREF="#DO_">DO_Class</A> - the implementation	<LI><A HREF="#DR_">DR_Class</A> - the &quot;smart pointer&quot; reference to DO_Class</UL><P>and</P><UL>	<LI>DOC_Class - private to DO_Class and DR_Class</UL><HR><A NAME="DO_"></A><H2>class DO_Class</H2><BLOCKQUOTE>	<BLOCKQUOTE>		<P>a public subclass of <A HREF="DObject.html">DO_Object</A>. . . <A HREF="D.html">D</A>	</BLOCKQUOTE>	<H4>Private instance variables</H4>	<BLOCKQUOTE>		<P><CODE>RWCString</CODE> <B>classname</B>		<BLOCKQUOTE>			The name of this class: for example, "X" as opposed to "DR_X" or "DO_X", etc.			This is a Rogue Wave string instead of a DR_String so the C++ compiler can			complete the class definitions; it could have been declared a DRef to point to			a DO_String, and this would be something we may want to do in the future, but			at this point, that seemed an unnecessary complexity. It will be necessary			when generic class objects can be created and when the class object stores			a representation of the interface as well.		</BLOCKQUOTE>							<P><CODE><A HREF="Drecycler.html">DR_recycler</A></CODE> <B>recycler</B>		<BLOCKQUOTE>			Manages the list of free objects		</BLOCKQUOTE>	</BLOCKQUOTE>	<H4>Class variables</H4>	<BLOCKQUOTE>		<P><CODE>static DR_Class <B>Classclass</B>		<BLOCKQUOTE>			Points to the metaclass object, an instance of DO_Class. Recycles class objects.		</BLOCKQUOTE>	</BLOCKQUOTE>	<H4>Public member functions</H4>	<BLOCKQUOTE>		<P><CODE>virtual <a href="D.html">D</a>*</CODE> </A> <B>New</B>		<CODE>( );</CODE>		<BLOCKQUOTE>			Return an object of this type. First asks the recycler for one, and if none			is returned, invokes the virtual function <CODE>spawn()</CODE>. 		</BLOCKQUOTE>				<P><CODE>virtual void</CODE> <A NAME="Recycle"></A><B>Recycle</B>			<CODE>();</CODE>		<BLOCKQUOTE>			<p>Returns an object to the recycler. This function is called by DRef::dump()			when the object's reference count drops to zero.</p>			<p>Subclasses may choose to override this			function to do a C++ delete; this is what DOC_Enumerator does.</p>		</BLOCKQUOTE>				<P><CODE>RWCString</CODE> <B>className</B>			<CODE>();</CODE>		<BLOCKQUOTE>			<p>Returns the name of the class. the Classclass object returns "Class".</p>		</BLOCKQUOTE>	</BLOCKQUOTE>		<H4>Private member functions</H4>	<BLOCKQUOTE>		<P><CODE>virtual <a href="D.html">D</a> *</CODE> <A NAME="spawn"></A><B>spawn</B>			<CODE>();</CODE>		<BLOCKQUOTE>			<p>Subclasses implement this			function to create and return an object of their type.</p>			<p><b>Note!</b> spawn() is the only place that an object should be instantiated with			the c++ <CODE>new</CODE> operator.</p>		</BLOCKQUOTE>		</blockquote>		<H4>Standard DO public member functions</H4>	<PRE>	DO_Class();	DO_Class(<A HREF="DRef.html">DRef</A> r);	virtual ~DO_Class();	static <A HREF="DClass.html">DR_Class</A> Classclass;		<FONT COLOR="#008000">the class object</FONT>	static DR_Class <A HREF="stdD.html#DO_New"><FONT SIZE="4"><B>New</B></FONT></A>();	<A HREF="DClass.html">DR_Class</A> <A HREF="stdD.html#DO_Class"><FONT SIZE="4"><B>DClass</B></FONT></A>();	DRef <A HREF="stdD.html#DO_route"><FONT SIZE="4"><B>route</B></FONT></A>(DR_<A HREF="DDMessage.html">Message</A> m);	void <A HREF="stdD.html#DO_init"><FONT SIZE="4"><B>init</B></FONT></A>();	void <A HREF="stdD.html#DO_destroy"><FONT SIZE="4"><B>destroy</B></FONT></A>();</PRE>		<H4>Future Stuff</H4>	<BLOCKQUOTE>		<P><CODE><a href="DDictionary.html">DR_Dictionary</a></CODE> <B>methods</B>;		<BLOCKQUOTE>			Message to method dictionary that instances of this class understands. Methods describe			formal parameters, etc.		</BLOCKQUOTE>			<P><CODE><a href="DDictionary.html">DR_Dictionary</a></CODE> <B>instanceVariables</B>;		<BLOCKQUOTE>			describes the types and names of instance variables		</BLOCKQUOTE>			<P><CODE><a href="DDictionary.html">DR_Dictionary</a></CODE> <B>classVariables</B>;		<BLOCKQUOTE>			describes the types and names of class variables shared by all instances		</BLOCKQUOTE>		</blockquote></BLOCKQUOTE><P><HR><!-- The DR class. First row is class name etc. --> <A NAME="DR_"></A><H2>class DR_Class</H2><BLOCKQUOTE>	<BLOCKQUOTE>		<P>a public subclass of <A HREF="DRef.html">DRef</A>	</BLOCKQUOTE>			<H4>Public member functions</H4>	<BLOCKQUOTE>		<P><CODE>void</CODE> <B>dump</B>		<CODE>(<a href="D.html">D</a>* d=0, <a href="D.html">ref_t</a> t=primary_ref);</CODE>		<BLOCKQUOTE>			 Directly invokes <CODE><a href="DRef.html#dump">DRef::dump</a>(d, t);</CODE>			 because Recycle() is overridden. See the note for DR_Class::Recycle().		</BLOCKQUOTE>			<P><CODE>void</CODE> <B>Recycle</B>		<CODE>(  );</CODE>		<BLOCKQUOTE>		<p>Called by DRef::dump() via DR_Class::dump()</p>		<p>Until it is useful for class objects to come and go like Strings or Ints,		instead of accumulating free class objects, we delete them. This must be done		when statically allocated DR_Class objects exist. global static destructors may		kill class objects in an order that we cannot easily specify; ~DRef() calls		DRef::dump() which calls Recycle(). Because objects are destructed from		the bottom up, calls to virtual functions from a destructor will only invoke		"this or higher" functions.</p>		<p>We must therefore override both dump() and Recycle()		for one to call the correct version of the other. And finally, because the objects		which compose a DO_Class object may have already had their class objects destroyed		by global static destructors, there will be no place to put them so they too		must be deleted. DO_Class::Recycle() will do this for objects for which no class		object can be found (eg, their Class() method returns DR_null)</p><PRE>	D *x = unsafe_get();	if (x) {		x-&gt;_destroy();		delete x;		_unsafe_clear();	}</PRE>		</BLOCKQUOTE>		</BLOCKQUOTE>			<H4>Standard DRef public member functions</H4>	<PRE>	<A HREF="stdD.html#DR_d_constructor">DR_Class (D *d=0)</A>;	<A HREF="stdD.html#DR_dref_constructor">DR_Class (const DRef&amp; ref)</A>;	virtual ~<A HREF="stdD.html#DR_destructor">DR_Class()</A>;</PRE>	<P>	<TABLE BORDER="1" CELLPADDING="3" CELLSPACING="0">	<TR>		<TD>			<P ALIGN="RIGHT"><I>note: <B>not</B> virtual functions</I>			<PRE>	DO_Class *<A HREF="stdD.html#DR_const_get"><FONT SIZE="4"><B>const_get</B></FONT></A>() <B>const</B>;	DO_Class *<A HREF="stdD.html#DR_safe_get"><FONT SIZE="4"><B>safe_get</B></FONT></A>();	DO_Class *<A HREF="stdD.html#DR_safe_set"><FONT SIZE="4"><B>safe_set</B></FONT></A>(D* d);	DO_Class *<A HREF="stdD.html#DR_New"><FONT SIZE="4"><B>New</B></FONT></A>();	inline DO_Class *<A HREF="stdD.html#DR_memberaccess"><FONT SIZE="4"><B>operator-&gt;</B></FONT></A>() { return <A			HREF="stdD.html#DR_safe_get">safe_get</A>(); }</PRE>		</TD>	</TR>	</TABLE></BLOCKQUOTE><HR><A HREF="#top">Top</A></BODY></HTML>