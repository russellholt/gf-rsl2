<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN"><HTML><HEAD>	<META NAME="GENERATOR" Content="Symantec Visual Page 1.0.2">	<META HTTP-EQUIV="Content-Type" CONTENT="text/html;CHARSET=iso-8859-1">	<TITLE>DComposite</TITLE></HEAD><BODY BGCOLOR="#FFFFFF"><P><A NAME="#Top"></A><H1>DComposite</H1><P><TABLE BORDER="0" CELLPADDING="5" CELLSPACING="0">	<TR>		<TD WIDTH="70%" VALIGN="TOP">			<BLOCKQUOTE>			<P>An object composed of several others. Instance variables, or attributes, are stored			in a <A HREF="DKeyedCollection.html">KeyedCollection</A> object whose implementation			object may be changed by a DO_Composite subclass.			</BLOCKQUOTE>			<P><B>DComposite</B> is			<UL>				<LI><A HREF="#DO_">DO_Composite</A> - the implementation				<LI><A HREF="#DR_">DR_Composite</A> - the &quot;smart pointer&quot; reference to				DO_Composite			</UL>		</TD>		<TD WIDTH="30%" VALIGN="TOP">			<TABLE BORDER="2" CELLPADDING="5" CELLSPACING="0" WIDTH="100%">				<TR>					<TD>						<P ALIGN="CENTER"><B>Other Important Information</B></P>						<CENTER>						<P><A HREF="#Composite Design"><IMG SRC="../art/composite_dsmall.gif" WIDTH="100"						HEIGHT="88" ALIGN="BOTTOM" ALT="Composite design" BORDER="2" HSPACE="2" VSPACE="2"><BR>						Design diagram</A></P>						<P><A HREF="#Macrobatics"><I>Composite macrobatics</I></A></CENTER>					</TD>				</TR>			</TABLE>		</TD>	</TR></TABLE><HR><A NAME="DO_"></A><H2>class DO_Composite</H2><BLOCKQUOTE>	<BLOCKQUOTE>		<P>a public subclass of <A HREF="DCollection.html">DO_Collection</A> . . . <A HREF="DObject.html">DO_Object</A>		. . . <A HREF="D.html">D</A>	</BLOCKQUOTE>	<H4>Private instance variables</H4>	<BLOCKQUOTE>		<P><A HREF="DKeyedCollection.html"><CODE>DR_KeyedCollection</CODE></A><CODE>		<b>storage</b> </CODE>		<BLOCKQUOTE>			<P>where instance variables are stored		</BLOCKQUOTE>	</BLOCKQUOTE>	<H4>Public member functions</H4>	<P><I>Inserting, finding, and removing objects</I></P>	<BLOCKQUOTE>		<P>See also the <A HREF="#macrobatics">Composite <I>macrobatics</I></A> for very		useful combinations of these functions</P>		<P><CODE>void</CODE> <B>add</B> <CODE>( const </CODE><A HREF="DString.html"><CODE>DR_String</CODE></A><CODE>&amp;		name, const </CODE><A HREF="DRef.html"><CODE>DRef</CODE></A><CODE>&amp; obj, </CODE><A		HREF="D.html"><CODE>ref_t</CODE></A><CODE> = primary_ref );</CODE>		<BLOCKQUOTE>			<P>add an object to the composite's collection, giving the name as a DR_String, and			optionally specifying the kind of reference to make to it.		</BLOCKQUOTE>		<P><CODE>void</CODE> <B>add</B> <CODE>( const char * name, const </CODE><A HREF="DRef.html"><CODE>DRef</CODE></A><CODE>&amp;		obj, </CODE><A HREF="D.html"><CODE>ref_t</CODE></A><CODE> = primary_ref );</CODE>		<BLOCKQUOTE>			<P>add an object to the composite's collection, giving the name as a const char *,			and optionally specifying the kind of reference to make to it.		</BLOCKQUOTE>		<P><CODE>void</CODE> <B>add</B> <CODE>( </CODE><A HREF="DObject.html"><CODE>DR_Object</CODE></A><CODE>,		</CODE><A HREF="D.html"><CODE>ref_t</CODE></A><CODE> = primary_ref );</CODE>		<BLOCKQUOTE>			<P>Inherited from <A HREF="DCollection.html">DO_Collection</A>; <B>this version of			</B>add<B> is not yet supported</B> because storing an object in a Composite requires			a key. Cases when there is no key or any key will do are certainly conceivable, and			a future implementation of this function ought to generate a suitably unique key.		</BLOCKQUOTE>		<P><A HREF="DRef.html"><CODE>DRef</CODE></A> <B>get</B> <CODE>( const </CODE><A HREF="DString.html"><CODE>DR_String</CODE></A><CODE>&amp;		name );</CODE>		<BLOCKQUOTE>			<P>get an object, specifiying name as DR_String		</BLOCKQUOTE>		<P><A HREF="DRef.html"><CODE>DRef</CODE></A> <B>get</B> <CODE>( const char * name		);</CODE>		<BLOCKQUOTE>			<P>get an object, specifying name as const char *		</BLOCKQUOTE>		<P><A HREF="DRef.html"><CODE>DR_void</CODE></A> <B>remove</B> <CODE>( </CODE><A HREF="DString.html"><CODE>DR_String</CODE></A><CODE>		name );</CODE>		<BLOCKQUOTE>			<P>remove the named object		</BLOCKQUOTE>	</BLOCKQUOTE>	<P><I>Composite information and aggregation</I></P>	<BLOCKQUOTE>		<P><CODE>void</CODE> <B>setStorage</B> <CODE>( </CODE><A HREF="DKeyedCollection.html"><CODE>DR_KeyedCollection</CODE></A><CODE>		drk, </CODE><A HREF="DRef.html"><CODE>ref_t</CODE></A><CODE> = primary_ref )</CODE>		<BLOCKQUOTE>			<P>Sets the internal storage of the Composite to any DO_KeyedCollection subclass.			Allows subclasses to change the default storage, which is <A HREF="DDictionary.html">DO_Dictionary</A>.		</BLOCKQUOTE>		<P><CODE>size_t</CODE> <B>size</B> <CODE>( ) const</CODE>		<BLOCKQUOTE>			<P>pass through to <CODE>storage-&gt;</CODE><A HREF="DKeyedCollection.html"><CODE>size</CODE></A><CODE>()</CODE>			to return the number of elements in the Composite's collection of instance variables.		</BLOCKQUOTE>		<P><A HREF="DCollection.html#Enumerator"><CODE>DO_Enumerator</CODE></A><CODE> *</CODE>		<B>elements</B> <CODE>( )</CODE>		<BLOCKQUOTE>			<P>Standard DO_Collection method. returns <CODE>storage-&gt;elements()</CODE> so			that one may traverse the collection of instance variables generically. Used by OStream			subclasses, such as <A HREF="DECI_OStream.html">ECI_OStream</A> for streaming.		</BLOCKQUOTE>		<P><CODE>void</CODE> <B>init</B> <CODE>( )</CODE>		<BLOCKQUOTE>			<P>creates/initializes composite <I>storage</I>.		</BLOCKQUOTE>		<P><CODE>void</CODE> <B>destroy</B> <CODE>( )</CODE>		<BLOCKQUOTE>			<P>dumps composite <I>storage</I>.		</BLOCKQUOTE>		<P><A HREF="DRef.html"><CODE>DRef</CODE></A> <B>route</B> <CODE>( </CODE><A HREF="DMessage.html"><CODE>DR_Message</CODE></A><CODE>		m )</CODE>		<BLOCKQUOTE>			<P>Responds to key messages of Composites by invoking their corresponding member			functions.		</BLOCKQUOTE>		<P><CODE>DR_String</CODE> <B>toString</B> <CODE>( )</CODE>		<BLOCKQUOTE>			<P>Implements simple streaming useful only for debugging. Use OStream for real streaming,			such as <A HREF="DECI_OStream.html">ECI_OStream</A>.		</BLOCKQUOTE>		<P><A HREF="DRef.html"><CODE>DRef</CODE></A> <B>deepCopy</B> <CODE>( ) const</CODE>		<BLOCKQUOTE>			<P>Creates a new object and calls assign().		</BLOCKQUOTE>		<P><CODE>void</CODE> <B>assign</B> <CODE>( const DRef&amp; obj )</CODE>		<BLOCKQUOTE>			<P>The somewhat unsolved problem with composite assign() is the inability as of yet			to connect any DO instance variables to both the composite storage and their native			c++ DR declarations...		</BLOCKQUOTE>		<P><A HREF="D.html"><CODE>dcompare_t</CODE></A> <B>compare</B> <CODE>( const </CODE><A		HREF="DRef.html"><CODE>DRef</CODE></A><CODE>&amp; d ) const</CODE></P>		<P><CODE>inline virtual </CODE><A HREF="DClass.html"><CODE>DR_Class</CODE></A> <B>DClass</B>		<CODE>( )</CODE>		<BLOCKQUOTE>			<P><CODE>{ return Compositeclass; }</CODE></P>		</BLOCKQUOTE>		<P><CODE>static</CODE> <A HREF="DClass.html">DR_Class</A> <B>Compositeclass</B>;		<BLOCKQUOTE>			<P>the class object for generic Composite objects.		</BLOCKQUOTE>	</BLOCKQUOTE>	<P><I>Standard DO public member functions</I></P>	<BLOCKQUOTE>		<P><CODE>DO_Composite ();</CODE><BR>		<CODE>DO_Composite (</CODE><A HREF="DRef.html"><CODE>DRef</CODE></A><CODE> r);</CODE><BR>		<CODE>virtual ~DO_Composite();</CODE>	</BLOCKQUOTE></BLOCKQUOTE><HR><h2><A NAME="Macrobatics"></A>Composite Macrobatics</H2><p>As illustrated in the <a href="#Composite Design">design diagram</a> below, objectaccessiblity (DO_ objects) from two ways - both dynamic and static - presents asynchronization problem. Dumping a DRef declared as a DO_Composite C++ instance variabledoes not dump it from the Composite's table.</p><p>The DO_ objects pointed to by both can be accessed and sent messages of any sort. Butto remove one does not remove it from the other; they must be dealt with simultaneouslywhen objects are created or destroyed. This becomes an actual C++ problem when werealize that objects are <I>keyed by name</I> in the composite's storage, which generallycorresponds to the name of the C++ variable....</P><p>To deal with this situation, several C++ macros are defined. The argument lists arepresented as C++ function argument lists, with types indicating what is expected.The actual macro definitions follow.</p><blockquote>	<P><CODE><B>DC_replacePtr</B> ( DRef dref_what, D* ptr_with )</CODE>	<BLOCKQUOTE>		To be executed in the context of a Composite for which <B>dref_what</B> is a local varable.		<ul>			<li><B>dref_what</B> will be set to point to <B>ptr_with</B>			<li>the old dref_what is removed from composite storage, using the			text of dref_what as the key name			<li>the new dref_what (that is, ptr_with) is added to the composite storage,			using the text of dref_what as the key name.		</ul><PRE>#define DC_replacePtr(dref_what, ptr_with)\	dref_what.replace(ptr_with);\	DO_Composite::remove( #dref_what );\	DO_Composite::add( #dref_what , dref_what)</PRE>	</BLOCKQUOTE>	<P><CODE><B>DC_replaceRef</B> ( DRef dref_what, DRef dref_with )</CODE>	<BLOCKQUOTE>		Similar to DC_replacePtr, but uses <CODE>dref_with-&gt;unsafe_get()</CODE> as		the D * to replace the contents of dref_what.<PRE>#define DC_replaceRef(dref_what, dref_with)\	dref_what.replace(dref_with.unsafe_get());\	DO_Composite::remove( #dref_what );\	DO_Composite::add( #dref_what , dref_what)</PRE>	</BLOCKQUOTE>	<P><CODE><B>DC_dump</B> ( DRef dr )</CODE>	<BLOCKQUOTE>		dumps dr and removes the entry from composite's storage whose key is the text		of the argument.<PRE>#define DC_dump(dr)\	dr.dump();\	DO_Composite::remove( (dr, #dr ) )</PRE>	</BLOCKQUOTE>	<P><CODE>DRef <B>DC_get</B> ( DRef var )</CODE>	<BLOCKQUOTE>		Looks up var in the composite storage, using the text of the argument as the key.		Returns (evaluates to) a DRef, which if not found, will be null.		The actual text of this macro is interesting (see below) because there is only		one argument to DO_Composite::get(), which is #var. This is the C++ comma operator,		which evaluates the left then the right of the comma and evaluates as an expression		to the right. By attempting to reference the actual var DRef, the compiler can		check that there is a match between the c++ variable name and the text of its key		in the composite storage.<PRE>#define DC_get( var ) DO_Composite::get( (var, #var ) )</PRE>	</BLOCKQUOTE>	<P><CODE><B>DC_remove</B> ( DRef var )</CODE>	<BLOCKQUOTE>		Same as DC_get, but removes the object and dumps the DRef var.<PRE>#define DC_remove( var ) DO_Composite::remove( (var, #var ) )</PRE>	</BLOCKQUOTE>	<P><CODE><B>DC_sync</B> ( var )</CODE>	<BLOCKQUOTE>		Replaces the local DRef var with that which is found in the composite's table		using the text of var as a key.<PRE>#define DC_sync( var ) var.replace( get( #var ) )</PRE>	</BLOCKQUOTE>	<P><CODE><B>DC_add</B> ( x )</CODE>	<BLOCKQUOTE>		Similar to DC_get and DC_remove for add.<PRE>#define DC_add(x) add( #x, x)</PRE>	</BLOCKQUOTE></BLOCKQUOTE><HR><H2><A NAME="Composite Design"></A>Composite Design</H2><table border="0" width="100%" cellspacing="10" cellpadding="5">	<tr><td>	<IMG SRC="../art/composite_details.gif" WIDTH="332" HEIGHT="287"		ALT="Composite design" BORDER="0" align="right">	<P>Instance variables	declared in a DO_Composite subclass are DR_ objects; these point to their repsective DO_	implementations. In addition, composite maintains a	<a href="DKeyedCollection.html">KeyedCollection</a> for generic access to these variables.</p></td></tr></table><HR><!-- The DR class. First row is class name etc. --><A NAME="DR_"></A><H2>class DR_Composite</H2><BLOCKQUOTE>	<BLOCKQUOTE>		<P>a public subclass of <A HREF="DCollection.html">DR_Collection</A> . . . <A HREF="DRef.html">DRef</A>	</BLOCKQUOTE>	<H4>Standard DRef public member functions</H4>	<PRE>	<A HREF="stdD.html#DR_d_constructor">DR_Composite (D *d=0)</A>;	<A HREF="stdD.html#DR_dref_constructor">DR_Composite (const DRef&amp; ref)</A>;	virtual ~<A HREF="stdD.html#DR_destructor">DR_Composite()</A>;</PRE>	<P>	<TABLE BORDER="1" CELLPADDING="3" CELLSPACING="0">	<TR>		<TD>			<P ALIGN="RIGHT"><I>note: <B>not</B> virtual functions</I></P>			<PRE>	DO_Composite *<A HREF="stdD.html#DR_const_get"><FONT SIZE="4"><B>const_get</B></FONT></A>() <B>const</B>;	DO_Composite *<A HREF="stdD.html#DR_safe_get"><FONT SIZE="4"><B>safe_get</B></FONT></A>();	DO_Composite *<A HREF="stdD.html#DR_safe_set"><FONT SIZE="4"><B>safe_set</B></FONT></A>(D* d);	DO_Composite *<A HREF="stdD.html#DR_New"><FONT SIZE="4"><B>New</B></FONT></A>();	inline DO_Composite *<A HREF="stdD.html#DR_memberaccess"><FONT SIZE="4"><B>operator-&gt;</B></FONT></A>() { return <A			HREF="stdD.html#DR_safe_get">safe_get</A>(); }</PRE>		</TD>	</TR>	</TABLE></BLOCKQUOTE><P><HR><A HREF="#top">Top</A></BODY></HTML>