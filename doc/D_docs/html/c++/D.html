<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN"><HTML><HEAD>	<META NAME="GENERATOR" Content="Symantec Visual Page 1.0.2">	<META HTTP-EQUIV="Content-Type" CONTENT="text/html;CHARSET=iso-8859-1">	<TITLE>D</TITLE></HEAD><BODY BGCOLOR="#FFFFFF"><P><A NAME="#Top"></A><H1>D</H1><BLOCKQUOTE>	<P>The parent class</P></BLOCKQUOTE><P><HR><H4><A NAME="definitions"></A>Significant definitions</H4><BLOCKQUOTE>	<P>	<P><CODE>enum ref_t { secondary_ref=0, primary_ref=1 };</CODE></P>	<P><CODE>enum dcompare_t { c_less=-1, c_equal=0, c_greater=1 };</CODE></P></BLOCKQUOTE><H2>class D</H2><BLOCKQUOTE>	<H4>Private instance variables</H4>	<BLOCKQUOTE>		<P><A HREF="#class RefCount"><CODE>RefCount</CODE></A> <B>ref_count</B>		<BLOCKQUOTE>			<P>Number of references to this object (both primary and secondary).		</BLOCKQUOTE>	</BLOCKQUOTE>	<H4>Public member functions</H4>	<P><I>General Virtuals</I></P>	<BLOCKQUOTE>		<P><CODE>virtual void</CODE> <A NAME="init"></A><B>init</B> <CODE>( )=0</CODE>		<BLOCKQUOTE>			<P>This should be treated as the constructor, which is invoked when new objects are			created. The superclass init() should always be called first before anything is done.		</BLOCKQUOTE>		<P><CODE>virtual void</CODE> <A NAME="destroy"></A><B>destroy</B> <CODE>( )=0</CODE>		<BLOCKQUOTE>			<P>This should be treated as the destructor, which is invoked when objects are &quot;freed&quot;.			DO_Object subclasses are recycled in type- specific lists of &quot;free&quot; objects.			The superclass's destroy() method should always be called last.		</BLOCKQUOTE>		<P><CODE>virtual DR_String</CODE> <A NAME="toString"></A><B>toString</B> <CODE>(		)=0</CODE>		<BLOCKQUOTE>			<P>Return a string value of self. A <A HREF="DBool.html">DO_Bool</A> which has the			value 0 will return &quot;false&quot;, for example. Primarily this is used for small-scale			stringification, and the OStream subclasses take precedence, such as the class <A			HREF="DECI_OStream.html">ECI_OStream</A> for ECI streaming.		</BLOCKQUOTE>		<P><CODE>virtual BOOLEAN</CODE> <A NAME="toBoolean"></A><B>toBoolean</B> <CODE>(		) const</CODE>		<BLOCKQUOTE>			<P>By default returns DR_FALSE.		</BLOCKQUOTE>		<P><CODE>virtual DRef</CODE> <A NAME="deepCopy"></A><B>deepCopy</B> <CODE>( ) const</CODE>		<BLOCKQUOTE>			<P>Return a copy of self. Class-specific, of course. <A HREF="DCollection.html"><CODE>DO_Collection</CODE></A><CODE>::deepCopy()</CODE>,			for example, returns a new collection with the deepCopy of each of its elements.		</BLOCKQUOTE>		<P><CODE>virtual void</CODE> <A NAME="assign"></A><B>assign</B> <CODE>( const DRef&amp;		obj )</CODE>		<BLOCKQUOTE>			<P>Assign self to the given object.		</BLOCKQUOTE>		<P><CODE>virtual </CODE><A HREF="#definitions"><CODE>dcompare_t</CODE></A> <A NAME="compare"></A><B>compare</B>		<CODE>( const DRef&amp; d ) const</CODE>		<BLOCKQUOTE>			<P>General comparison. returns c_less, c_equal, or c_greater.		</BLOCKQUOTE>		<P><CODE>virtual DRef</CODE> <A NAME="Class"></A><B>Class</B> <CODE>( )</CODE>		<BLOCKQUOTE>			<P>Get this object's Class object. Returns a <A HREF="DRef.html">DRef</A> rather			than <A HREF="DClass.html">DR_Class</A> to eliminate circular class definitions.			This DRef points to a DO_Class, of course.		</BLOCKQUOTE>	</BLOCKQUOTE>	<P><I>Dynamic Messaging</I></P>	<BLOCKQUOTE>		<P><CODE>virtual DRef</CODE> <A NAME="route"></A><B>route</B> <CODE>(DR_Message m)=0</CODE>		<BLOCKQUOTE>			<P>Respond to the given message <I>m</I>. Typically will <CODE>switch (m-&gt;messageCode)</CODE>			and return the result of a function invocation named in the message object.		</BLOCKQUOTE>		<P><CODE>virtual DRef</CODE> <A NAME="doesNotUnderstand"></A><B>doesNotUnderstand</B>		<CODE>(DR_Message m )</CODE>		<BLOCKQUOTE>			<P>Invoked by the default case of D::route(), which means that the method indicated			by <CODE>m-&gt;message</CODE> was not found in any subclass. By default does nothing;			subclasses may override this function to implement class-specific behavior when a			message is not found (that is, not understood).		</BLOCKQUOTE>	</BLOCKQUOTE>	<P><I>D-specific methods</I></P>	<BLOCKQUOTE>		<P><CODE>int</CODE> <B>operator <CODE>==</CODE></B> <CODE>(const D&amp; d)</CODE>		<BLOCKQUOTE>			<P><I>pointer</I> comparison! that is, <CODE>return (this == &amp;d)</CODE>		</BLOCKQUOTE>		<P><CODE>inline int</CODE> <B>refCount</B> <CODE>( ) const</CODE>		<BLOCKQUOTE>			<P>Gets the reference count, which means the number of primary references. invokes			<CODE>ref_count.Primary();</CODE>		</BLOCKQUOTE>		<P><CODE>DR_String</CODE> <B>cpp_classname</B> <CODE>( )</CODE>		<BLOCKQUOTE>			<P>Use C++ RTTI to get the name of the C++ class.		</BLOCKQUOTE>		<P><CODE>virtual void</CODE> <B>_init</B> <CODE>( )</CODE>		<BLOCKQUOTE>			<P>invokes D::init() and <B>initializes the refcount to zero</B>. Called by DO_Class::New()			when an object is created or pulled from the free list.		</BLOCKQUOTE>		<P><CODE>virtual void</CODE> <B>_destroy</B> <CODE>( )</CODE>		<BLOCKQUOTE>			<P>invokes D::destroy()		</BLOCKQUOTE>	</BLOCKQUOTE>	<P><A NAME="constructors"></A><I>Constructors &amp; Destructors</I></P>	<BLOCKQUOTE>		<P><B>D</B> <CODE>( )</CODE>		<BLOCKQUOTE>			<P>nothing other than ref count initialization.		</BLOCKQUOTE>		<P><CODE>virtual</CODE> <B>~ D</B> <CODE>( )</CODE>		<BLOCKQUOTE>			<P>Does nothing other than inidicate that <I>all subclasses should implement a virtual			destructor</I> so that objects may be correctly destroyed when necessary, otherwise			<CODE>delete</CODE> of a <CODE>D *</CODE> would only free the portion of the object			which is a D. Object deletion would happen in <A HREF="DClass.html#Recycle"><CODE>DO_Class::Recycle</CODE></A><CODE>()</CODE>			if object recycling is turned off or memory is tight.		</BLOCKQUOTE>	</BLOCKQUOTE></BLOCKQUOTE><H4><A NAME="global operators"></A>global operators</H4><BLOCKQUOTE>	<P><CODE>int</CODE> <B>operator <CODE>&lt;</CODE></B> <CODE>(const DRef&amp; left,	const DRef&amp; right )</CODE>	<BLOCKQUOTE>		<P>true if <CODE>left-&gt;</CODE><A HREF="#compare"><CODE>compare</CODE></A><CODE>(right)</CODE>		is c_less	</BLOCKQUOTE>	<P><CODE>int</CODE> <B>operator <CODE>&lt;=</CODE></B> <CODE>(const DRef&amp; left,	const DRef&amp; right )</CODE>	<BLOCKQUOTE>		<P>true if <CODE>left-&gt;</CODE><A HREF="#compare"><CODE>compare</CODE></A><CODE>(right)</CODE>		is c_less or c_equal	</BLOCKQUOTE>	<P><CODE>int</CODE> <B>operator <CODE>&gt;</CODE></B> <CODE>(const DRef&amp; left,	const DRef&amp; right )</CODE>	<BLOCKQUOTE>		<P>true if <CODE>left-&gt;</CODE><A HREF="#compare"><CODE>compare</CODE></A><CODE>(right)</CODE>		is c_greater	</BLOCKQUOTE>	<P><CODE>int</CODE> <B>operator <CODE>&gt;=</CODE></B> <CODE>(const DRef&amp; left,	const DRef&amp; right )</CODE>	<BLOCKQUOTE>		<P>true if <CODE>left-&gt;</CODE><A HREF="#compare"><CODE>compare</CODE></A><CODE>(right)</CODE>		is c_greater or c_equal	</BLOCKQUOTE></BLOCKQUOTE><P><HR><H2><A NAME="class RefCount"></A>class RefCount</H2><BLOCKQUOTE>	<P>Used by D for ref count access management. Has both a primary and secondary reference.</P>	<H4>Private Instance Variables</H4>	<BLOCKQUOTE>		<P><CODE>short</CODE> <B>primary, secondary</B>		<BLOCKQUOTE>			<P>The number of primary and secondary references.		</BLOCKQUOTE>	</BLOCKQUOTE>	<H4>Public Member Functions</H4>	<PRE>	RefCount() { init(); }		inline int <A NAME="Primary"></A>Primary() const {	return primary; }	inline int Secondary() const {	return secondary; }		inline int newReference() { return newPrimary(); }	inline int decReference() { return decPrimary(); }		int newReference(ref_t);	int decReference(ref_t);		inline int newPrimary() { return ++primary; }	inline int decPrimary() { return --primary; }	inline int newSecondary() { return ++secondary; }	inline int decSecondary() { return --secondary; }		inline int operator++() { return newPrimary(); }	// prefix	inline int operator++(int) { return newPrimary(); } // postfix		inline int operator--() { return decPrimary(); }	inline int operator--(int) { return decPrimary(); }		inline void init() { primary=0, secondary=0; }</PRE></BLOCKQUOTE><P><HR><A HREF="#top">Top</A></BODY></HTML>