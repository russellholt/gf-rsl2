<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN"><HTML><HEAD>	<META NAME="GENERATOR" Content="Symantec Visual Page 1.0.2">	<META HTTP-EQUIV="Content-Type" CONTENT="text/html;CHARSET=iso-8859-1">	<TITLE>DRef</TITLE></HEAD><BODY BGCOLOR="#FFFFFF"><P><A NAME="#Top"></A><H1>DRef</H1><BLOCKQUOTE>	<P>The parent of all smart pointer classes, that is, the super-smart pointer.</BLOCKQUOTE><P><HR><H4><A NAME="definitions"></A>Significant definitions</H4><P><CODE>#define DR_null (DNULL)<BR>#define DR_void DRef</CODE><H2>class DRef</H2><BLOCKQUOTE>	<BLOCKQUOTE>		<P>a public subclass of <A HREF="D.html">D</A>	</BLOCKQUOTE>	<H4>Private instance variables</H4>	<BLOCKQUOTE>		<P><A HREF="D.html"><CODE>D</CODE></A><CODE> *that;</CODE>	</BLOCKQUOTE>	<H4>Public member functions</H4>	<P><A NAME="constructors"></A><I>Constructors</I></P>	<BLOCKQUOTE>		<P><B>DRef</B> <CODE>(</CODE><A HREF="D.html"><CODE>D</CODE></A><CODE> *d=0);</CODE>		<BLOCKQUOTE>			<P>initialize with the given D. invokes <A HREF="#dump"><CODE>dump</CODE></A><CODE>(d)</CODE>.		</BLOCKQUOTE>		<P><B>DRef</B> <CODE>(</CODE><A HREF="D.html"><CODE>D</CODE></A><CODE> *d, </CODE><A		HREF="D.html#definitions"><CODE>ref_t</CODE></A><CODE> kind);</CODE>		<BLOCKQUOTE>			<P>initialize with the given D and reference kind. invokes <A HREF="#dump"><CODE>dump</CODE></A><CODE>(d,			kind)</CODE>.		</BLOCKQUOTE>		<P><B>DRef</B> <CODE>(const DRef&amp; dref);</CODE>		<BLOCKQUOTE>			<P>initialize with the given DRef's pointer. invokes <A HREF="#dump"><CODE>dump</CODE></A><CODE>(dref.</CODE><A			HREF="#unsafe_get"><CODE>unsafe_get</CODE></A><CODE>())</CODE>.		</BLOCKQUOTE>		<P><B>DRef</B> <CODE>(const DRef&amp; dref, ref_t kind);</CODE>		<BLOCKQUOTE>			<P>initialize with the given DRef's pointer and reference kind. invokes <A HREF="#dump"><CODE>dump</CODE></A><CODE>(dref.</CODE><A			HREF="#unsafe_get"><CODE>unsafe_get</CODE></A><CODE>(), kind)</CODE>.		</BLOCKQUOTE>	</BLOCKQUOTE>	<P><I>Public Information</I></P>	<BLOCKQUOTE>		<P><CODE>inline D *</CODE> <A NAME="unsafe_get"></A><B>unsafe_get</B> <CODE>( ) const		{ return that; }</CODE>		<BLOCKQUOTE>			<P>Get the pointer. It's &quot;unsafe&quot; because it does no type or validity checking,			meaning the pointer must be checked before it is useable. Most subclasses provide			(non-virtual) <B>safe_get()</B> and <B>const_get()</B> methods.		</BLOCKQUOTE>		<P><CODE>inline int</CODE> <A NAME="isValid"></A><B>isValid()</B> <CODE>( ) const		{ return that != DNULL; }</CODE>		<BLOCKQUOTE>			<P>compares the pointer against <A HREF="#definitions">DNULL</A>. Validity here means			non-null, rather than type safety of being a correct <A HREF="D.html">D</A> class.		</BLOCKQUOTE>		<P><CODE>inline </CODE><A HREF="D.html#definitions"><CODE>ref_t</CODE></A> <B>RefKind</B>		<CODE>( ) const { return refKind; }</CODE>		<BLOCKQUOTE>			<P>Get the kind of reference we are.		</BLOCKQUOTE>	</BLOCKQUOTE>	<P><I>Setting and dumping the D pointer</I></P>	<BLOCKQUOTE>		<P>These methods all essentially do the same thing. dump is the most general and		can be used to do what the rest of them do. The variety of verbs provides ways to		give different meaning in a different contexts to what is intended. replace versus		set demonstrates a different expectation, although they work the same way.</P>		<P><CODE>virtual void</CODE> <A NAME="dump"></A><B>dump</B> <CODE>(D* d=0, ref_t		ref_kind=primary_ref );</CODE>		<BLOCKQUOTE>			<P>Decrement's <I>that</I>'s reference count; if this count becomes zero, <A HREF="#Recycle">Recycle</A>()			is invoked. Finally, <I>that</I> is set to point to <I>d</I>, which could be null.			Often used simply as <CODE>dump()</CODE>.		</BLOCKQUOTE>		<P><CODE>inline void</CODE> <B>replace</B> <CODE>(D* d, ref_t ref_kind = primary_ref		)</CODE>		<BLOCKQUOTE>			<P>invokes <A HREF="#dump"><CODE>dump</CODE></A><CODE>(d, ref_kind);</CODE>		</BLOCKQUOTE>		<P><CODE>inline void</CODE> <B>replaceWithPrimary</B> <CODE>(D* d )</CODE>		<BLOCKQUOTE>			<P>invokes <A HREF="#dump"><CODE>dump</CODE></A><CODE>(d, primary_ref);</CODE>		</BLOCKQUOTE>		<P><CODE>inline void</CODE> <B>replaceWithSecondary</B> <CODE>(D* d )</CODE>		<BLOCKQUOTE>			<P>invokes <A HREF="#dump"><CODE>dump</CODE></A><CODE>(d, secondary_ref);</CODE>		</BLOCKQUOTE>		<P><CODE>inline void</CODE> <B>setPrimary</B> <CODE>(D* d );</CODE>		<BLOCKQUOTE>			<P>invokes <A HREF="#dump"><CODE>dump</CODE></A><CODE>(d, primary_ref);</CODE>		</BLOCKQUOTE>		<P><CODE>inline void</CODE> <B>setSecondary</B> <CODE>(D* d );</CODE>		<BLOCKQUOTE>			<P>invokes <A HREF="#dump"><CODE>dump</CODE></A><CODE>(d, secondary_ref);</CODE>		</BLOCKQUOTE>	</BLOCKQUOTE>	<P><I>Smart methods (safe pass-throughs)</I></P>	<BLOCKQUOTE>		<P>These methods are &quot;pass-throughs&quot; to the private pointer <I>that</I>.		all check the pointer, and if non-null, call the method of the same name in <I>that</I>.</P>		<P><CODE>void</CODE> <B>init</B> <CODE>( )</CODE>		<BLOCKQUOTE>			<P>invokes <CODE>that-&gt;init()</CODE>.		</BLOCKQUOTE>		<P><CODE>void</CODE> <B>destroy</B> <CODE>( )</CODE>		<BLOCKQUOTE>			<P>invokes <CODE>that-&gt;destroy()</CODE>.		</BLOCKQUOTE>		<P><CODE>DR_String</CODE> <B>toString</B> <CODE>( )</CODE>		<BLOCKQUOTE>			<P>invokes <CODE>that-&gt;toString()</CODE>.		</BLOCKQUOTE>		<P><CODE>int</CODE> <B>toBoolean</B> <CODE>( )</CODE>		<BLOCKQUOTE>			<P>invokes <CODE>that-&gt;toBoolean()</CODE>.		</BLOCKQUOTE>		<P><CODE>unsigned</CODE> <B>dtypeid</B> <CODE>( )</CODE>		<BLOCKQUOTE>			<P>invokes <CODE>that-&gt;dtypeid()</CODE>.		</BLOCKQUOTE>		<P><CODE>dcompare_t</CODE> <B>compare</B> <CODE>(const DRef&amp; d) const</CODE>		<BLOCKQUOTE>			<P>invokes <CODE>that-&gt;compare(d)</CODE>.		</BLOCKQUOTE>		<P><CODE>void</CODE> <B>assign</B> <CODE>(const DRef&amp; obj)</CODE>		<BLOCKQUOTE>			<P>invokes <CODE>that-&gt;assign()</CODE>.		</BLOCKQUOTE>		<P><CODE>DRef</CODE> <B>Class</B> <CODE>()</CODE>		<BLOCKQUOTE>			<P>invokes <CODE>that-&gt;Class()</CODE>.		</BLOCKQUOTE>		<P><CODE>DRef</CODE> <B>route</B> <CODE>(DR_Message m)</CODE>		<BLOCKQUOTE>			<P>invokes <CODE>that-&gt;route(m)</CODE>.		</BLOCKQUOTE>	</BLOCKQUOTE>	<H4>Protected member functions</H4>	<BLOCKQUOTE>		<P>Available to subclasses only</P>		<P><CODE>inline void</CODE> <A NAME="_unsafe_clear"></A><B>_unsafe_clear</B> <CODE>()		{ that = </CODE><A HREF="#definitions"><CODE>DNULL</CODE></A><CODE>; }</CODE>		<BLOCKQUOTE>			<P>Dangerously clear the pointer. <B>unsafe</B> refers to the fact that this function			can be called only by those who know exactly what they are doing because it affects			memory management. This function is called by <A HREF="#dump"><CODE>dump</CODE></A><CODE>()</CODE>			and subclasses that will override memory management facilities.		</BLOCKQUOTE>		<P><CODE>virtual void</CODE> <A NAME="Recycle"></A><B>Recycle</B> <CODE>()</CODE>		<BLOCKQUOTE>			<P>Essentially <CODE>that-&gt;Class()-&gt;</CODE><A HREF="DClass.html#Recycle"><CODE>Recycle</CODE></A><CODE>(that)</CODE>,			in other words, give <I>that</I> to its class object to recycle - which will either			be put on the free list or destroyed. (Note that subclasses of <A HREF="DClass.html">DO_Class</A>			can change this behavior)</P>			<P>Called by <A HREF="#dump"><CODE>dump</CODE></A><CODE>()</CODE> when <I>that</I>'s			ref count is zero.</P>		</BLOCKQUOTE>	</BLOCKQUOTE>	<H4>Protected instance variables</H4>	<BLOCKQUOTE>		<P><CODE>ref_t</CODE> <B>refKind</B>		<BLOCKQUOTE>			<P>The kind of reference this DRef is; either primary or secondary, with the values			primary_ref or secondary_ref respectively.		</BLOCKQUOTE>	</BLOCKQUOTE>	<H4>Functions that shouldn't be overridden or called</H4>	<BLOCKQUOTE>		<P><CODE>inline int</CODE> <B>decRef</B> <CODE>() { return refCount(); }</CODE>		<BLOCKQUOTE>			<P>Overrides <CODE>D::decRef()</CODE> so that DRef objects cannot be deleted in the			event that one DRef points to another. That situation will be possible in the future			but it currently is dangerous. Don't change the behavior of this function if you			override it!		</BLOCKQUOTE>	</BLOCKQUOTE></BLOCKQUOTE><P><HR><A HREF="#top">Top</A></BODY></HTML>