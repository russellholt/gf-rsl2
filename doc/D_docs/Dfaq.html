<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN"><HTML><HEAD>	<META NAME="GENERATOR" Content="Symantec Visual Page 1.0.2">	<META HTTP-EQUIV="Content-Type" CONTENT="text/html;CHARSET=iso-8859-1">	<TITLE>untitled</TITLE></HEAD><BODY><CENTER><P><A HREF="DestinyC++.html"><FONT SIZE="2">Destiny C++</FONT></A><B> </B>| <A HREF="Overview.html"><FONTSIZE="2">Overview</FONT></A><B><BR></B><A HREF="Objects.html"><FONT SIZE="2">Class and Object Design</FONT></A><B> </B>|<B></B><A HREF="rsl2d.html"><FONT SIZE="2">rsl2D</FONT></A><B> </B>|<B> </B><A HREF="R_D.html"><FONTSIZE="2">R_D</FONT></A> | <FONT SIZE="2">Martin's Questions</FONT> <BR><HR></P></CENTER><P><FONT SIZE="6"><TT><B>Martin's Questions</B></TT></FONT></P><P>These questions are ordered as Martin asked and I answered.</P><H4>Sept 16</H4><P><FONT COLOR="#000077"><TT>&gt;Am I right in assuming that only those attributesthat are to be<BR>&gt;accessed directly in RSL need to be specified in the rsl classes that<BR>&gt;are fed into rsl2D? And that therefore attributes that are only<BR>&gt;referenced in the C++ implementation can be added to the C++ classes<BR>&gt;outside the scope of rsl2D?</TT><BR></FONT><BR>As much as possible (with a couple of exceptions) should be represented by D classes,which implies RSL declarations. RSL should be treated as a design language, not asan information hiding accessibility layer. However, if you decide to have a more-or-lessprivate instance variable, you should still use D classes to represent it. This doesn'tmean that it is inaccessible from RSL, however, because of the fluid way that RSLviews objects -- rsl accessibility is simply an add() away.<BR><BR><FONT COLOR="#000077"><TT>&gt;I have concluded that I need to write a new collectionclass to wrap<BR>&gt;the RWTValSortedVector&lt;DRef&gt; collection. I'm assuming it would be<BR>&gt;unacceptable to simply assign the contents of the Sorted Vector into a<BR>&gt;DOList class before returning it to an rsl caller, because we are trying<BR>&gt;to avoid translations. Am I right?</TT><BR></FONT><BR>Yes, and we have to delay the discussion of collection implementation until it isworking; but essentially, if your collection class correctly implements the collectioninterface, it should be able to be treated as if it were a List or a Table from withinRSL -- it's R_D's job to make that happen. Details like how R_D or RSL knows it shouldbe a List or a Table or something else will be discussed later.<BR><BR><FONT COLOR="#000077"><TT>&gt;From what I understand, in 2.2, a Resource method thatwas<BR>&gt;implemented in C++ did not even appear in the rsl version of the class.</TT><BR></FONT><BR>I don't understand this statement. The rsl &quot;version&quot; of the class describesthe class's interface in RSL; anything excluded is not accessible from RSL. <BR><BR><FONT COLOR="#000077"><TT>&gt;If this is true, is the same principle carrying overto 2.5? If so, does<BR>&gt;this means that the rsl class processed by rsl2D would subsequently have<BR>&gt;to be edited to remove those methods?</TT><BR></FONT><BR>Whether you currently plan for certain things to be useable within RSL should notnecessarily be the deciding factor to whether it is included in the class. RSL shouldbe treated as a design language. do not change an rsl class for the purposes of codegeneration. The real goal is for *everything* to be accessible from RSL whether youintend to use it that way or not.<BR><BR><FONT COLOR="#000077"><TT>&gt;If a method is implemented in rsl, and referenced onlywithin rsl,<BR>&gt;does it need to appear in the rsl class which is processed by rsl2D?</TT><BR></FONT><BR>absolutely yes. There are a few things like this (eg, access control) which rsl2Ddoes not yet take into account but will. I think the way it will work is that rsl2Dwill only generate for declarations prefixed by the keyword &quot;native&quot;, like&quot;native String s;&quot; or &quot;native String method();&quot; or &quot;nativemethod();&quot;<BR><BR><FONT COLOR="#000077"><TT>&gt;Or can it be added to the rsl class outside the scopeof rsl2D?<BR></TT></FONT><BR>don't do this, you're asking for serious version control trouble!<BR><BR><FONT COLOR="#000077"><TT>&gt;I understand what the R_D rsl datatype is capable of,but I'm not<BR>&gt;sure how or when I would use it. Or is it &quot;behind the covers&quot;?<BR></TT></FONT><BR>It's an internal thing; the only time you would ever use it is if you created a newResource that works with D classes. I doubt you will need to do this.</P><P><HR></P><H4>Sept 22</H4><P><FONT COLOR="#000077"><TT>&gt;1) I am creating a Decimal class, to wrap RogueWave'sRWDecimalPortable<BR>&gt;class (it's the only on that comes with DBTools - I believe Skip is<BR>&gt;looking into buying Money.h++ which has more efficient Decimal classes).<BR>&gt;In order to generate an operator+ (etc.) method, can I just code<BR>&gt;operator+ in rsl and run that through rsl2D? Or will I have to make do<BR>&gt;with an add() (etc.) method?<BR></TT></FONT><BR>We already have Money.h++. We've had it for more than a year.<BR><BR>Yes you can declare operator methods in RSL, but <A HREF="rsl2d.html">rsl2D</A> doesn'tcorrectly translate the names yet. don't let that stop you. Look at String.rsl orInteger.rsl for the syntax and remember that RSL is quite unlike C++ in every respectyou can imagine.<BR><BR>As of today (9/22) I do not believe you have enough information to complete sucha set of classes.. see me<BR><BR><BR><FONT COLOR="#000077"><TT>&gt;2) Can the DR_Ref New() method take a parameter thatis passed to the<BR>&gt;constructor? Or should I just use a separate method to initialize<BR>&gt;instance variables?<BR></TT></FONT><BR>see <A HREF="D-releases.html">http://vision.destinyusa.com/tech/ideas/c++standard/D-releases.html</A><BR>You can write a version of New which invokes the default New() and does whateveryou like. However, init() will already have been invoked on the new object. See DString.hfor an example of this.<BR><BR><BR><FONT COLOR="#000077"><TT>&gt;3) I am planning to return a DR_Status from methodsin the public<BR>&gt;interface of DO_Object derived classes. I believe this conforms with<BR>&gt;rsl error-handling conventions. Do you see any problem with this? Are<BR>&gt;you going to create DO_Status/DR_Status classes?<BR></TT></FONT><BR>The problem I have is that it has not been effective for RSL. I hate returning statusobjects in a huge way.<BR><BR><FONT COLOR="#000077"><TT>&gt;4) I have a method in which I want to return a stringliteral, something<BR>&gt;like this:<BR>&gt; DR_String getSectionTitle()<BR>&gt; {DR_String ret;<BR>&gt; ret.New();<BR>&gt; ret = &quot;Cash Assets&quot;;<BR>&gt; return ret;}<BR>&gt;Does that look correct? I instinctively avoid returning (C++) references<BR>&gt;to local variables, because they go out of scope, but DRefs are returned<BR>&gt;by value, right? So it will return a (shallow?) copy of the local<BR>&gt;DR_String variable, and there is no scope problem?<BR></TT></FONT><BR>You can do<BLOCKQUOTE>	<P><TT>DR_String ret = &quot;Cash Assets&quot;);<BR>	return ret;</TT></BLOCKQUOTE><P>or</P><BLOCKQUOTE>	<P><TT>return DR_String(&quot;Cash Assets&quot;);</TT></BLOCKQUOTE><P>Remember that DR objects are pointers to DO objects. Copying a DR means that thetwo DR objects point to the same DO.<BR><BR><FONT COLOR="#000077"><TT>&gt;5) When you have created DO/DR classes for some ofthe basic rsl data<BR>&gt;types, will I be able to use their methods directly from C++? I thinking<BR></TT></FONT><BR>Yes. That is the goal. See the small example dtestmain.cc in the directory mentionedon the releases site above.<BR><BR><FONT COLOR="#000077"><TT>&gt;specifically of List. If I have<BR>&gt; DR_List aList;<BR>&gt;will I be able to code, for instance, &quot;aList[2]&quot; in C++?<BR></TT></FONT><BR>I don't know about that, specifically - maybe one day, probably not this week. collectioniteration (enumeration) is already available.<BR><BR><FONT COLOR="#000077"><TT>&gt;6) To use the rsl2D tool, must there be just one classper input rsl<BR>&gt;file?<BR></TT></FONT><BR>Technically no, but remember that the RSL classes you are creating are not simplyfor rsl2D; they define the interface for RSL, which means they must be used in theproduction system. Just like String.rsl, Integer.rsl, etc. For example, they shouldbe commented before run through rsl2D so those comments appear in both the RSL versionfor the RSL programmer and in C++ for the C++ programmer. This means that one classper RSL file, <I>classname</I>.rsl, etc.</P><P><HR></P><CENTER><P><A HREF="splash.html"><FONT SIZE="2">Destiny C++</FONT></A><B> </B>| <A HREF="DestinyC++.html"><FONTSIZE="2">Overview</FONT></A><A HREF="DestinyC++.html#TOC-Standard"><FONT SIZE="2"><BR></FONT></A><A HREF="Objects.html"><FONT SIZE="2">Class and Object Design</FONT></A><B></B>|<B> </B><A HREF="rsl2d.html"><FONT SIZE="2">rsl2D</FONT></A><B> </B>|<B> </B><AHREF="R_D.html"><FONT SIZE="2">R_D</FONT></A> | <FONT SIZE="2">Martin's Questions</FONT></P><P><HR></CENTER></BODY></HTML>